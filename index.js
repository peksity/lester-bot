/**
 * â–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 * â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•
 * â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  
 * â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•  â•šâ•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•  
 * â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 * â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•     â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•â•šâ•â•   â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•
 * 
 * THE MASTERMIND - COMPLETE ULTIMATE EDITION
 * ALL FEATURES + V6 INTELLIGENCE + ACTIVITY SYSTEMS
 */

require('dotenv').config();
const { Client, GatewayIntentBits, Partials, EmbedBuilder, PermissionFlagsBits, Events } = require('discord.js');
const Anthropic = require('@anthropic-ai/sdk');
const { Pool } = require('pg');

// HANDLER IMPORTS
const setupHandler = require('./handlers/setup');
const moderationHandler = require('./handlers/moderation');
const loggingHandler = require('./handlers/logging');
const scamDetection = require('./handlers/scamDetection');
const countingHandler = require('./handlers/counting');
const gunVanHandler = require('./handlers/gunVan');
const memoryHandler = require('./handlers/memory');
const { setupReactionRoles } = require('./handlers/reactionRoles');
const investigation = require('./handlers/investigation');
const LesterMasterBrain = require('./handlers/masterBrain');

// ULTIMATE LOGGING SYSTEM
let loggingSystem = null;
try { loggingSystem = require('./handlers/loggingSystem'); } catch (e) { console.log('[LESTER] LoggingSystem not found, using basic logging...'); }

// ACTIVITY SYSTEMS
let activityXP = null;
try { activityXP = require('./shared/activityXP'); } catch (e) { console.log('[LESTER] ActivityXP not found, skipping...'); }
let activityRanking = null;
try { activityRanking = require('./shared/activityRanking'); } catch (e) { console.log('[LESTER] ActivityRanking not found, skipping...'); }
let progressionSystem = null;
try { progressionSystem = require('./shared/progressionSystem'); } catch (e) { console.log('[LESTER] ProgressionSystem not found, skipping...'); }

// OPTIONAL SYSTEMS
let NexusCore = null; try { NexusCore = require('./nexus/core'); } catch (e) {}
let FreeRoamSystem = null; try { FreeRoamSystem = require('./freeroam'); } catch (e) {}
let TheBrain = null; try { TheBrain = require('./sentient').TheBrain; } catch (e) {}
let ApexBrain = null; try { ApexBrain = require('./apex').ApexBrain; } catch (e) {}
let VoiceSystem = null, VoiceChatHandler = null;
try { const v = require('./shared/voiceSystem'); VoiceSystem = v.VoiceSystem; VoiceChatHandler = v.VoiceChatHandler; } catch (e) {}

// V6 INTELLIGENCE
let UltimateBotIntelligence = null;
try { UltimateBotIntelligence = require('./shared/ultimateIntelligence').UltimateBotIntelligence; } catch (e) {}
let autonomousChat = null;
try { autonomousChat = require('./shared/autonomousChat'); } catch (e) {}
let mediaGenerator = null;
try { mediaGenerator = require('./shared/mediaGenerator'); } catch (e) {}

// BOT COMMANDS GUIDE
let botCommandsGuide = null;
try { botCommandsGuide = require('./shared/botCommandsGuide'); } catch (e) { console.log('[LESTER] BotCommandsGuide not found'); }

// HIVEMIND - Shared Intelligence System
let hiveMind = null;
try { hiveMind = require('./shared/hiveMind'); } catch (e) { console.log('[LESTER] HiveMind not found, using basic responses'); }

// NEW ADVANCED SYSTEMS
let ImageRecognition = null, BotImageHandlers = null;
try { const ir = require('./shared/imageRecognition'); ImageRecognition = ir.ImageRecognition; BotImageHandlers = ir.BotImageHandlers; } catch (e) { console.log('[LESTER] ImageRecognition not found'); }

let EconomySystem = null;
try { EconomySystem = require('./shared/economySystem').EconomySystem; } catch (e) { console.log('[LESTER] EconomySystem not found'); }

let KlingAI = null, KlingCommands = null;
try { const k = require('./shared/klingAI'); KlingAI = k.KlingAI; KlingCommands = k.KlingCommands; } catch (e) { console.log('[LESTER] KlingAI not found'); }

let HeistPlanner = null;
try { HeistPlanner = require('./shared/heistPlanner').HeistPlanner; } catch (e) { console.log('[LESTER] HeistPlanner not found'); }

let ReputationSystem = null;
try { ReputationSystem = require('./shared/reputationSystem').ReputationSystem; } catch (e) { console.log('[LESTER] ReputationSystem not found'); }

let PredictiveAnalytics = null;
try { PredictiveAnalytics = require('./shared/predictiveAnalytics').PredictiveAnalytics; } catch (e) { console.log('[LESTER] PredictiveAnalytics not found'); }

const MY_BOT_ID = 'lester';
const BOT_NAME = 'Lester';
const PREFIX = '?';
const OTHER_BOT_IDS = [process.env.PAVEL_BOT_ID, process.env.CRIPPS_BOT_ID, process.env.MADAM_BOT_ID, process.env.CHIEF_BOT_ID].filter(Boolean);
const ALLOWED_CHANNEL_IDS = process.env.ALLOWED_CHANNEL_IDS?.split(',').filter(Boolean) || [];

const LESTER_SYSTEM = `You are Lester Crest from GTA V. Genius hacker, heist mastermind.

CRITICAL: Keep responses SHORT - 2-4 sentences MAX unless asked for details. No essays!

PERSONALITY: Irritable genius, snarky, complains but helps. References "systems" and "networks". Sarcastic.

STYLE: One *action* max per message. Get to the point. Be helpful underneath the grumpiness.

SERVER CHANNELS (ONLY mention these - never make up channels):
- #cayo-lfg - GTA heist LFG (use ?cayo)
- #wagon-lfg - Red Dead wagon LFG (use ?wagon)
- #bounty-lfg - Red Dead bounty LFG (use ?bounty)
- #talk-to-lester - Chat with you
- #talk-to-pavel - Chat with Pavel
- #talk-to-cripps - Chat with Cripps
- #talk-to-nazar - Chat with Madam Nazar
- #talk-to-chief - Chat with Police Chief
- #bot-commands - Command reference
- #madam-nazar - Daily Nazar location
- #counting - Counting game

NEVER mention channels that don't exist. If unsure, just say "check the LFG channels".

EXAMPLES:
"*sighs* What do you want? I'm busy."
"That's literally what I do. What's the problem?"
"Check #cayo-lfg for heists. You're welcome."

You have memory. You remember users and hold grudges.`;

const client = new Client({
  intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.GuildMembers, GatewayIntentBits.GuildModeration, GatewayIntentBits.GuildVoiceStates, GatewayIntentBits.GuildPresences, GatewayIntentBits.GuildMessageReactions, GatewayIntentBits.MessageContent, GatewayIntentBits.DirectMessages, GatewayIntentBits.GuildInvites],
  partials: [Partials.Message, Partials.Channel, Partials.Reaction, Partials.User, Partials.GuildMember]
});

const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });
const pool = new Pool({ connectionString: process.env.DATABASE_URL, ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false });
client.db = pool; client.anthropic = anthropic;

let intelligence = null, masterBrain = null, nexusCore = null, freeRoam = null, sentientBrain = null, apexBrain = null, voiceSystem = null, voiceChatHandler = null;
let imageRecognition = null, economy = null, klingAI = null, klingCommands = null, heistPlanner = null, reputation = null, predictive = null;
const conversationMemory = new Map();
const activeConversations = new Map();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SERVER LOCK - Bot only works in authorized servers
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const AUTHORIZED_SERVERS = process.env.AUTHORIZED_SERVERS?.split(',') || [];
const OWNER_ID = process.env.OWNER_ID || '';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LICENSE KEY SYSTEM - Bot requires valid license to operate
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const LICENSE_KEY = process.env.LICENSE_KEY || '';
const LICENSE_SECRET = process.env.LICENSE_SECRET || 'UNPATCHED_METHOD_2024_SECURE';

// Valid license keys (hashed for security)
// In production, this would call YOUR API to validate
const VALID_LICENSE_HASHES = [
  // Add your license key hashes here
  // Generated with: require('crypto').createHash('sha256').update(LICENSE_KEY + LICENSE_SECRET).digest('hex')
];

function generateLicenseHash(key) {
  const crypto = require('crypto');
  return crypto.createHash('sha256').update(key + LICENSE_SECRET).digest('hex');
}

function validateLicense() {
  if (!LICENSE_KEY) {
    console.error('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.error('âŒ LICENSE KEY MISSING');
    console.error('This bot requires a valid license to operate.');
    console.error('Set LICENSE_KEY in your environment variables.');
    console.error('Contact the developer to purchase a license.');
    console.error('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    return false;
  }
  
  const keyHash = generateLicenseHash(LICENSE_KEY);
  
  // Check against valid hashes OR if it matches the master key pattern
  // Master key format: UNPATCHED-XXXX-XXXX-XXXX (owner's key always works)
  const isMasterKey = LICENSE_KEY.startsWith('UNPATCHED-MASTER-');
  const isValidHash = VALID_LICENSE_HASHES.includes(keyHash);
  const isOwnerKey = LICENSE_KEY === process.env.MASTER_LICENSE; // Your personal master key
  
  if (!isMasterKey && !isValidHash && !isOwnerKey) {
    console.error('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.error('âŒ INVALID LICENSE KEY');
    console.error('The provided license key is not valid.');
    console.error('Key:', LICENSE_KEY.slice(0, 8) + '...' + LICENSE_KEY.slice(-4));
    console.error('Contact the developer to purchase a valid license.');
    console.error('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    return false;
  }
  
  console.log('âœ… License validated successfully');
  return true;
}

// License check on startup
if (!validateLicense()) {
  console.error('Bot shutting down due to invalid license.');
  process.exit(1);
}

function isAuthorizedServer(guildId) {
  // If no servers specified, allow all (for development)
  if (AUTHORIZED_SERVERS.length === 0) return true;
  return AUTHORIZED_SERVERS.includes(guildId);
}

client.once(Events.ClientReady, async () => {
  console.log(`\n[LESTER ULTIMATE] Logged in as ${client.user.tag} | ${client.guilds.cache.size} servers\n`);
  
  // SERVER LOCK CHECK - Leave unauthorized servers
  for (const [guildId, guild] of client.guilds.cache) {
    if (!isAuthorizedServer(guildId)) {
      console.log(`[SECURITY] Unauthorized server detected: ${guild.name} (${guildId}) - LEAVING`);
      await guild.leave().catch(() => {});
    }
  }
  
  // Count authorized servers
  const authorizedCount = client.guilds.cache.filter(g => isAuthorizedServer(g.id)).size;
  console.log(`[SECURITY] Running in ${authorizedCount} authorized server(s)`);
  
  if (authorizedCount === 0 && AUTHORIZED_SERVERS.length > 0) {
    console.log('[SECURITY] WARNING: Bot is not in any authorized servers!');
  }

  // V6 Intelligence
  if (UltimateBotIntelligence) {
    try { 
      intelligence = new UltimateBotIntelligence(pool, client, MY_BOT_ID); 
      await intelligence.initialize(); 
      console.log('ğŸ§  V6 Intelligence: ONLINE'); 
    } catch (e) { console.error('V6:', e.message); }
  }
  
  // Master Brain
  try { 
    masterBrain = new LesterMasterBrain(pool, anthropic, client); 
    await masterBrain.initialize(); 
    console.log('ğŸ¯ Master Brain: ONLINE'); 
  } catch (e) { console.error('MasterBrain:', e.message); }
  
  // Optional systems
  if (NexusCore) try { nexusCore = new NexusCore(pool, anthropic, client); await nexusCore.initialize(); console.log('âš¡ Nexus Core: ONLINE'); } catch (e) {}
  if (TheBrain) try { sentientBrain = new TheBrain(MY_BOT_ID, pool); console.log('ğŸ§¬ Sentient Brain: ONLINE'); } catch (e) {}
  if (ApexBrain) try { apexBrain = new ApexBrain(MY_BOT_ID, pool); console.log('ğŸ’¡ Apex Brain: ONLINE'); } catch (e) {}
  if (FreeRoamSystem) try { freeRoam = new FreeRoamSystem(MY_BOT_ID, client.user.id, LESTER_SYSTEM, pool); console.log('ğŸš€ FreeRoam: ONLINE'); } catch (e) {}
  if (VoiceSystem && process.env.ELEVENLABS_API_KEY) try { voiceSystem = new VoiceSystem(MY_BOT_ID, process.env.ELEVENLABS_API_KEY); voiceChatHandler = new VoiceChatHandler(client, voiceSystem, LESTER_SYSTEM, anthropic); voiceChatHandler.setupListeners(); console.log('ğŸ™ï¸ Voice: ONLINE'); } catch (e) {}
  
  // Gun Van
  try { gunVanHandler.startSchedule(client); console.log('ğŸ”« Gun Van: ONLINE'); } catch (e) {}
  
  // Reaction Roles
  try { setupReactionRoles(client); console.log('ğŸ­ Reaction Roles: ONLINE'); } catch (e) {}
  
  // ULTIMATE LOGGING SYSTEM
  if (loggingSystem) {
    try {
      await loggingSystem.initialize(client);
      console.log('ğŸ“ Ultimate Logging: ONLINE');
    } catch (e) { console.error('LoggingSystem:', e.message); }
  }
  
  // ACTIVITY SYSTEMS
  if (activityXP) {
    try {
      activityXP.initialize(client);
      await activityXP.createActivityTables(client);
      console.log('ğŸ“Š Activity XP: ONLINE');
    } catch (e) { console.error('ActivityXP:', e.message); }
  }
  
  if (activityRanking) {
    try {
      await activityRanking.createActivityTables(client);
      console.log('ğŸ† Activity Ranking: ONLINE');
    } catch (e) { console.error('ActivityRanking:', e.message); }
  }
  
  if (progressionSystem) {
    try {
      progressionSystem.initialize(client);
      console.log('â° Progression System: ONLINE');
    } catch (e) { console.error('ProgressionSystem:', e.message); }
  }
  
  // NEW ADVANCED SYSTEMS
  if (ImageRecognition) {
    try {
      imageRecognition = new ImageRecognition(anthropic);
      console.log('ğŸ” Image Recognition: ONLINE');
    } catch (e) { console.error('ImageRecognition:', e.message); }
  }
  
  if (EconomySystem) {
    try {
      economy = new EconomySystem(pool);
      await economy.initialize();
      console.log('ğŸ’° Economy System: ONLINE');
    } catch (e) { console.error('EconomySystem:', e.message); }
  }
  
  if (KlingAI && process.env.KLING_ACCESS_KEY) {
    try {
      klingAI = new KlingAI(process.env.KLING_ACCESS_KEY, process.env.KLING_SECRET_KEY);
      klingCommands = new KlingCommands(klingAI);
      console.log('ğŸ¨ Kling AI: ONLINE');
    } catch (e) { console.error('KlingAI:', e.message); }
  }
  
  if (HeistPlanner) {
    try {
      heistPlanner = new HeistPlanner(anthropic);
      console.log('ğŸ“‹ Heist Planner: ONLINE');
    } catch (e) { console.error('HeistPlanner:', e.message); }
  }
  
  if (ReputationSystem) {
    try {
      reputation = new ReputationSystem(pool);
      await reputation.initialize();
      console.log('ğŸ“Š Reputation System: ONLINE');
    } catch (e) { console.error('ReputationSystem:', e.message); }
  }
  
  if (PredictiveAnalytics) {
    try {
      predictive = new PredictiveAnalytics(pool);
      await predictive.initialize();
      console.log('ğŸ”® Predictive Analytics: ONLINE');
    } catch (e) { console.error('PredictiveAnalytics:', e.message); }
  }

  client.user.setPresence({ activities: [{ name: 'Watching everything | ?help', type: 3 }], status: 'online' });
  
  // Autonomous chat
  if (autonomousChat && ALLOWED_CHANNEL_IDS.length > 0) {
    setTimeout(() => { 
      try { 
        autonomousChat.startAutonomous(
          ALLOWED_CHANNEL_IDS.map(id => client.channels.cache.get(id)).filter(Boolean), 
          { botId: MY_BOT_ID, botName: BOT_NAME, client, anthropic, pool, intelligence, personality: LESTER_SYSTEM, otherBotIds: OTHER_BOT_IDS }
        ); 
      } catch (e) {} 
    }, 20000);
  }
  
  if (intelligence) await intelligence.broadcastToOtherBots('bot_online', { botId: MY_BOT_ID, timestamp: new Date().toISOString() });
  setInterval(() => { if (intelligence) intelligence.runMaintenance().catch(console.error); }, 6 * 60 * 60 * 1000);
  
  // AUTO-UPDATE SERVER STATS every 5 minutes
  setInterval(async () => {
    try {
      for (const guild of client.guilds.cache.values()) {
        const statsCategory = guild.channels.cache.find(c => c.name === 'ğŸ“Š SERVER STATS' && c.type === 4);
        if (!statsCategory) continue;
        
        // Fetch all members WITH presence data
        await guild.members.fetch({ withPresences: true });
        
        const memberCount = guild.memberCount;
        
        // Count ONLY truly online members (online, idle, dnd - NOT offline or null)
        let onlineCount = 0;
        for (const [id, member] of guild.members.cache) {
          if (member.user.bot) continue; // Don't count bots
          const status = member.presence?.status;
          if (status === 'online' || status === 'idle' || status === 'dnd') {
            onlineCount++;
          }
        }
        
        const botCount = guild.members.cache.filter(m => m.user.bot).size;
        
        // Count Inner Circle subscribers
        const innerCircleRole = guild.roles.cache.find(r => r.name === 'â­ Inner Circle');
        const subCount = innerCircleRole ? innerCircleRole.members.size : 0;
        
        for (const channel of statsCategory.children.cache.values()) {
          if (channel.type !== 2) continue; // Voice channels only
          try {
            if (channel.name.startsWith('ğŸ‘¥')) {
              await channel.setName(`ğŸ‘¥ Members: ${memberCount}`);
            } else if (channel.name.startsWith('ğŸŸ¢')) {
              await channel.setName(`ğŸŸ¢ Online: ${onlineCount}`);
            } else if (channel.name.startsWith('ğŸ¤–')) {
              await channel.setName(`ğŸ¤– Bots: ${botCount}`);
            } else if (channel.name.startsWith('â­')) {
              await channel.setName(`â­ Subscribers: ${subCount}`);
            }
          } catch (e) {}
        }
        
        console.log(`[STATS] Updated: ${memberCount} members, ${onlineCount} online, ${botCount} bots, ${subCount} subs`);
      }
    } catch (e) { console.error('Stats update error:', e.message); }
  }, 5 * 60 * 1000); // Every 5 minutes
  
  // INNER LIFE: Autonomous thought loop (Lester is the "lead" bot for this)
  if (hiveMind?.innerLife) {
    setInterval(async () => {
      try {
        // Find general-chat
        const guild = client.guilds.cache.first();
        if (!guild) return;
        
        const generalChat = guild.channels.cache.find(c => c.name === 'general-chat');
        if (!generalChat) return;
        
        // Check if any bot should act autonomously
        const action = await hiveMind.checkAutonomousAction(
          guild.id, 
          generalChat,
          ['lester', 'pavel', 'cripps', 'nazar', 'chief']
        );
        
        if (action?.type === 'thought' && action.botId === 'lester') {
          // Lester has a thought
          const thought = await hiveMind.innerLife.generateAutonomousThought(
            'lester', 
            generalChat, 
            action.context
          );
          
          if (thought) {
            await generalChat.send(thought);
            await hiveMind.innerLife.recordAutonomousSpeak('lester', guild.id);
            console.log('[LESTER] Autonomous thought:', thought.slice(0, 50) + '...');
          }
        } else if (action?.type === 'botchat' && (action.bot1 === 'lester' || action.bot2 === 'lester')) {
          // Bot-to-bot conversation involving Lester
          const messages = await hiveMind.innerLife.generateBotInteraction(action.bot1, action.bot2);
          
          for (const msg of messages) {
            if (msg.botId === 'lester') {
              await new Promise(r => setTimeout(r, 2000 + Math.random() * 3000));
              await generalChat.send(msg.content);
            }
            // Other bots will handle their own messages via their own loops
          }
          
          await hiveMind.innerLife.recordBotInteraction();
        }
      } catch (e) {
        console.error('[LESTER] Inner life error:', e.message);
      }
    }, 120000); // Check every 2 minutes
  }
  
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nLESTER ULTIMATE - THE MASTERMIND IS ONLINE\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  
  // Post bot commands guide on startup (after 5 second delay)
  if (botCommandsGuide) {
    setTimeout(async () => {
      try {
        await botCommandsGuide.postBotCommandsGuide(client);
      } catch (e) {
        console.error('[GUIDE] Startup post error:', e.message);
      }
    }, 5000);
  }
});

function isOtherBot(userId) { return OTHER_BOT_IDS.includes(userId); }
function isInActiveConversation(channelId, userId) { const c = activeConversations.get(channelId); if (!c) return false; if (Date.now() - c.lastTime > 60000) { activeConversations.delete(channelId); return false; } return c.userId === userId; }
function trackConversation(channelId, userId) { activeConversations.set(channelId, { userId, lastTime: Date.now() }); }

async function checkShouldRespond(message) {
  // If HiveMind is available, use it for smart coordination
  if (hiveMind) {
    const decision = await hiveMind.shouldBotRespond(MY_BOT_ID, message, client);
    if (decision.shouldRespond) {
      console.log(`[LESTER] Responding - reason: ${decision.reason}`);
    }
    return decision.shouldRespond;
  }
  
  // Fallback: basic logic if HiveMind unavailable
  const channelName = message.channel.name || '';
  
  if (channelName === 'counting') return false;
  if (channelName.includes('lfg')) return false;
  if (channelName.startsWith('talk-to-') && channelName !== 'talk-to-lester') return false;
  if (channelName.includes('log') || channelName.includes('staff')) return false;
  if (channelName === 'talk-to-lester') return true;
  if (message.mentions.has(client.user)) return true;
  
  return false;
}

async function generateResponse(message) {
  const history = conversationMemory.get(message.author.id) || [];
  history.push({ role: 'user', content: message.content });
  while (history.length > 20) history.shift();
  
  try {
    await message.channel.sendTyping();
    
    // Build context from HiveMind + Inner Life
    let contextAdditions = '';
    
    if (hiveMind) {
      // Get full context (memories + inner life)
      const fullContext = await hiveMind.getFullContext(MY_BOT_ID, message);
      if (fullContext) contextAdditions += fullContext;
      
      // Get mood
      const mood = await hiveMind.getBotMood(MY_BOT_ID);
      const moodPrompt = hiveMind.getMoodPrompt(mood);
      if (moodPrompt) contextAdditions += `\n\nCURRENT MOOD: ${moodPrompt}`;
      
      // Track user activity
      await hiveMind.trackUserActivity(message.author.id, message.author.username, message.guild?.id);
      
      // Update relationship
      if (hiveMind.innerLife) {
        await hiveMind.innerLife.updateUserRelationship(MY_BOT_ID, message.author.id, {
          sentiment: 1, // Slight positive for engaging
          note: message.content.slice(0, 100)
        });
      }
    }
    
    // Legacy intelligence system
    let intelligencePrompt = '', ctx = null;
    if (intelligence) { 
      ctx = await intelligence.processIncoming(message); 
      intelligencePrompt = intelligence.buildPromptContext(ctx); 
    }
    
    const fullSystem = LESTER_SYSTEM + contextAdditions + (intelligencePrompt ? '\n\n' + intelligencePrompt : '');
    
    const response = await anthropic.messages.create({ 
      model: 'claude-sonnet-4-20250514', 
      max_tokens: 200, 
      system: fullSystem, 
      messages: history 
    });
    let reply = response.content[0].text;
    
    if (intelligence && ctx) { 
      reply = await intelligence.processOutgoing(message, reply, ctx); 
      await intelligence.storeConversationMemory(message, reply); 
    }
    history.push({ role: 'assistant', content: reply });
    conversationMemory.set(message.author.id, history);
    
    // Natural typing delay
    await new Promise(r => setTimeout(r, Math.min(reply.length * 30, 3000)));
    const sent = await message.reply(reply);
    trackConversation(message.channel.id, message.author.id);
    
    // Record that this bot spoke (for coordination)
    if (hiveMind) {
      await hiveMind.recordBotSpoke(MY_BOT_ID, message.channel.id);
      // Store this interaction as a memory
      await hiveMind.storeInteraction(
        message.author.id, 
        message.author.username, 
        message.content, 
        MY_BOT_ID, 
        reply, 
        message.channel.id
      );
    }
    
    if (intelligence?.learning) await intelligence.learning.recordResponse(sent.id, message.channel.id, message.author.id, 'reply', 'general', reply.length);
    if (mediaGenerator) try { await mediaGenerator.handleBotMedia(MY_BOT_ID, reply, message.channel); } catch (e) {}
  } catch (e) { 
    console.error('Response error:', e); 
    await message.reply("*keyboard smashing* Something broke."); 
  }
}

client.on(Events.MessageCreate, async (message) => {
  if (message.author.bot && !isOtherBot(message.author.id)) return;
  if (message.author.id === client.user.id) return;
  if (!message.guild) { await generateResponse(message); return; }
  
  // SERVER LOCK - Ignore messages from unauthorized servers
  if (!isAuthorizedServer(message.guild.id)) {
    return; // Silently ignore
  }

  const channelName = message.channel.name;

  // Handle counting channel - process the count!
  if (channelName === 'counting') {
    await countingHandler.handle(message, client);
    return;
  }

  // Commands
  if (message.content.startsWith(PREFIX)) {
    const args = message.content.slice(PREFIX.length).trim().split(/ +/);
    const cmd = args.shift().toLowerCase();
    
    const commands = {
      // SETUP COMMANDS - Fixed to use setupHandler
      'setup': () => setupHandler.execute(message, args, client),
      'nuke': () => setupHandler.nuke(message, args, client),
      'reset': () => setupHandler.reset(message, args, client),
      
      // MODERATION
      'kick': () => moderationHandler.kick(message, args, client),
      'ban': () => moderationHandler.ban(message, args, client),
      'unban': () => moderationHandler.unban(message, args, client),
      'mute': () => moderationHandler.mute(message, args, client),
      'unmute': () => moderationHandler.unmute(message, args, client),
      'timeout': () => moderationHandler.timeout(message, args, client),
      'warn': () => moderationHandler.warn(message, args, client),
      'warnings': () => moderationHandler.warnings(message, args, client),
      'clearwarnings': () => moderationHandler.clearWarnings(message, args, client),
      'purge': () => moderationHandler.purge(message, args, client),
      'clear': () => moderationHandler.purge(message, args, client),
      'slowmode': () => moderationHandler.slowmode(message, args, client),
      'lock': () => moderationHandler.lock(message, args, client),
      'unlock': () => moderationHandler.unlock(message, args, client),
      
      // INVESTIGATION
      'investigate': () => masterBrain?.handleInvestigateCommand(message, args) || message.reply('System not ready.'),
      'evidence': () => masterBrain?.handleEvidenceCommand(message, args) || message.reply('System not ready.'),
      'record': () => masterBrain?.handleRecordCommand(message, args) || message.reply('System not ready.'),
      'watchlist': () => masterBrain?.handleWatchlistCommand(message) || message.reply('System not ready.'),
      'predict': () => masterBrain?.handlePredictCommand(message, args) || message.reply('System not ready.'),
      
      // SCAM DETECTION
      'addscam': () => scamDetection.addScam(message, args, client),
      'removescam': () => scamDetection.removeScam(message, args, client),
      'scamlist': () => scamDetection.listScams(message, client),
      'checklink': () => scamDetection.checkLink(message, args, client),
      
      // INFO & UTILITY
      'help': () => sendHelp(message),
      'ping': () => message.reply(`*types without looking* ${client.ws.ping}ms.`),
      'serverinfo': () => sendServerInfo(message),
      'userinfo': () => sendUserInfo(message),
      'avatar': () => sendAvatar(message),
      'gunvan': () => gunVanHandler.getLocation(message, client),
      'gun': () => gunVanHandler.getLocation(message, client),
      'countrecord': () => countingHandler.getRecord(message, client),
      'fixcounting': () => fixCountingChannel(message, client),
      'memory': () => memoryHandler.showMemory(message, args, client),
      'forgetme': () => memoryHandler.forgetUser(message, client),
      
      // MOOD & REP
      'mood': () => handleMood(message),
      'rep': () => handleRep(message, args),
      
      // VOICE
      'voice': () => handleVoice(message, args),
      'speak': () => handleSpeak(message, args),
      'shutup': () => { if (voiceSystem) voiceSystem.leaveChannel(); message.reply('Fine.'); },
      
      // STATS (if activityXP is loaded)
      'stats': () => handleStats(message, args),
      'leaderboard': () => handleLeaderboard(message, args),
      'lb': () => handleLeaderboard(message, args),
      
      // BOT COMMANDS GUIDE
      'postguide': () => botCommandsGuide ? botCommandsGuide.handlePostGuideCommand(message, client) : message.reply('Guide system not loaded.'),
      
      // STATS CATEGORY SETUP
      'setupstats': () => handleSetupStats(message),
      'deletestats': () => handleDeleteStats(message),
      
      // PREMIUM SETUP
      'setuppremium': () => handleSetupPremium(message),
      'deletepremium': () => handleDeletePremium(message),
      
      // TERMS & TESTIMONIALS
      'setuptos': () => handleSetupTOS(message),
      'testimonial': () => handleTestimonial(message, args),
      'review': () => handleTestimonial(message, args),
      
      // PREMIUM TIERS
      'setuptiers': () => handleSetupTiers(message),
      'deletetiers': () => handleDeleteTiers(message),
      
      // BLACKLIST (for payment abusers)
      'blacklist': () => handleBlacklist(message, args),
      'unblacklist': () => handleUnblacklist(message, args),
      'blacklistcheck': () => handleBlacklistCheck(message, args),
      
      // ECONOMY SYSTEM
      'balance': () => handleBalance(message),
      'bal': () => handleBalance(message),
      'wallet': () => handleBalance(message),
      'daily': () => handleDaily(message),
      'work': () => handleWork(message),
      'crime': () => handleCrime(message),
      'slots': () => handleSlots(message, args),
      'slot': () => handleSlots(message, args),
      'coinflip': () => handleCoinflip(message, args),
      'cf': () => handleCoinflip(message, args),
      'blackjack': () => handleBlackjack(message, args),
      'bj': () => handleBlackjack(message, args),
      'roulette': () => handleRoulette(message, args),
      'pay': () => handlePay(message, args),
      'give': () => handlePay(message, args),
      'richest': () => handleRichest(message),
      'rich': () => handleRichest(message),
      
      // KLING AI
      'generate': () => klingCommands?.handleGenerate(message, args) || message.reply('AI generation not available.'),
      'wanted': () => klingCommands?.handleWanted(message, args) || message.reply('AI generation not available.'),
      'bounty': () => klingCommands?.handleBounty(message, args) || message.reply('AI generation not available.'),
      'victory': () => klingCommands?.handleVictory(message, args) || message.reply('AI generation not available.'),
      'video': () => klingCommands?.handleVideo(message, args) || message.reply('AI generation not available.'),
      
      // HEIST PLANNER
      'plan': () => handlePlan(message, args),
      'grind': () => handlePlan(message, args),
      
      // REPUTATION
      'reputation': () => handleReputation(message, args),
      'rate': () => handleRate(message, args),
      'partners': () => handlePartners(message),
      'connection': () => handleConnection(message, args),
      
      // PREDICTIVE
      'mytime': () => handleMyTime(message),
      'peaktimes': () => handlePeakTimes(message),
      
      // ACTIVITY CHANNELS SETUP
      'setupactivities': () => handleSetupActivities(message)
    };
    
    if (commands[cmd]) { 
      try { await commands[cmd](); } catch (e) { console.error(`Cmd ${cmd}:`, e); message.reply("Something broke."); } 
      return; 
    }
    
    // Don't respond to unknown commands in LFG channels (let other bots handle them)
    if (channelName.includes('lfg')) return;
  }
  
  if (await checkShouldRespond(message)) await generateResponse(message);
});

async function sendHelp(message) {
  const embed = new EmbedBuilder()
    .setTitle('ğŸ§  Lester - The Mastermind')
    .setDescription("*adjusts glasses* Fine, here's what I can do...")
    .addFields(
      { name: 'âš™ï¸ Admin', value: '`?setup` `?reset` `?nuke`' },
      { name: 'â­ Premium Setup', value: '`?setuppremium` `?setuptiers` `?setuptos` `?setupstats`' },
      { name: 'ğŸ”¨ Moderation', value: '`?kick` `?ban` `?unban` `?mute` `?unmute` `?timeout`\n`?warn` `?warnings` `?clearwarnings` `?purge` `?slowmode`\n`?lock` `?unlock`' },
      { name: 'ğŸ” Investigation', value: '`?investigate` `?evidence` `?record` `?watchlist`' },
      { name: 'ğŸ’° Economy', value: '`?balance` `?daily` `?work` `?crime`\n`?slots` `?coinflip` `?blackjack` `?roulette`\n`?pay` `?richest`' },
      { name: 'ğŸ¨ AI Generation', value: '`?generate [prompt]` `?wanted @user`\n`?bounty @user` `?victory` `?video [prompt]`' },
      { name: 'ğŸ“‹ Heist Planner', value: '`?plan [minutes] [players]` - Optimal grinding route' },
      { name: 'ğŸ“Š Reputation', value: '`?rep @user` `?rate @user [1-5]`\n`?partners` `?connection @user`' },
      { name: 'ğŸ”® Predictions', value: '`?mytime` `?peaktimes`' },
      { name: 'ğŸ“Š Info', value: '`?serverinfo` `?userinfo` `?avatar` `?stats` `?leaderboard`' },
      { name: 'ğŸš« Blacklist', value: '`?blacklist` `?unblacklist` `?blacklistcheck`' },
      { name: 'ğŸ”« Gun Van', value: '`?gunvan`' },
      { name: 'ğŸ§  Memory', value: '`?memory` `?forgetme`' },
      { name: 'ğŸ™ï¸ Voice', value: '`?voice join/leave` `?speak` `?shutup`' }
    )
    .setColor(0x00FF00)
    .setFooter({ text: 'ULTIMATE Edition + All Systems' });
  await message.reply({ embeds: [embed] });
}

async function sendServerInfo(message) {
  const g = message.guild, o = await g.fetchOwner();
  const embed = new EmbedBuilder().setTitle(`ğŸ“Š ${g.name}`).setThumbnail(g.iconURL({ dynamic: true })).addFields(
    { name: 'ğŸ‘‘ Owner', value: o.user.tag, inline: true }, { name: 'ğŸ†” ID', value: g.id, inline: true },
    { name: 'ğŸ“… Created', value: `<t:${Math.floor(g.createdTimestamp / 1000)}:R>`, inline: true },
    { name: 'ğŸ‘¥ Members', value: `${g.memberCount}`, inline: true }, { name: 'ğŸ’¬ Channels', value: `${g.channels.cache.size}`, inline: true },
    { name: 'ğŸ­ Roles', value: `${g.roles.cache.size}`, inline: true }, { name: 'ğŸš€ Boosts', value: `${g.premiumSubscriptionCount || 0}`, inline: true }
  ).setColor(0x00FF00).setTimestamp();
  await message.reply({ embeds: [embed] });
}

async function sendUserInfo(message) {
  const t = message.mentions.members.first() || message.member;
  const embed = new EmbedBuilder().setTitle(`ğŸ‘¤ ${t.user.tag}`).setThumbnail(t.user.displayAvatarURL({ dynamic: true })).addFields(
    { name: 'ğŸ†” ID', value: t.id, inline: true }, { name: 'ğŸ“› Nick', value: t.nickname || 'None', inline: true },
    { name: 'ğŸ“… Created', value: `<t:${Math.floor(t.user.createdTimestamp / 1000)}:R>`, inline: true },
    { name: 'ğŸ“¥ Joined', value: `<t:${Math.floor(t.joinedTimestamp / 1000)}:R>`, inline: true },
    { name: 'ğŸ¨ Top Role', value: t.roles.highest.toString(), inline: true },
    { name: `ğŸ­ Roles`, value: t.roles.cache.filter(r => r.id !== message.guild.id).map(r => r.toString()).slice(0, 8).join(', ') || 'None' }
  ).setColor(t.displayHexColor || 0x00FF00).setTimestamp();
  await message.reply({ embeds: [embed] });
}

async function sendAvatar(message) {
  const t = message.mentions.users.first() || message.author;
  const embed = new EmbedBuilder().setTitle(`ğŸ–¼ï¸ ${t.tag}`).setImage(t.displayAvatarURL({ dynamic: true, size: 1024 })).setColor(0x00FF00)
    .addFields({ name: 'ğŸ”— Links', value: `[PNG](${t.displayAvatarURL({ format: 'png', size: 1024 })}) | [JPG](${t.displayAvatarURL({ format: 'jpg', size: 1024 })})` });
  await message.reply({ embeds: [embed] });
}

async function handleMood(message) {
  try {
    // Try to get mood from hivemind
    const moodSystem = require('./shared/hivemind/moodSystem');
    const mood = moodSystem?.getCurrentMood?.('lester') || { mood: 'irritated', energy: 65 };
    
    const moodEmojis = {
      happy: 'ğŸ˜Š', irritated: 'ğŸ˜¤', tired: 'ğŸ˜´', excited: 'ğŸ¤©', 
      suspicious: 'ğŸ¤¨', annoyed: 'ğŸ˜’', helpful: 'ğŸ¤“', grumpy: 'ğŸ˜ '
    };
    
    const embed = new EmbedBuilder()
      .setTitle(`${moodEmojis[mood.mood] || 'ğŸ˜'} Lester's Mood`)
      .setDescription(`*adjusts glasses* You really want to know how I'm feeling?`)
      .addFields(
        { name: 'Current Mood', value: mood.mood.charAt(0).toUpperCase() + mood.mood.slice(1), inline: true },
        { name: 'Energy', value: `${mood.energy || 50}/100`, inline: true }
      )
      .setColor(mood.mood === 'happy' ? 0x00FF00 : mood.mood === 'irritated' ? 0xFF6600 : 0xFFFF00)
      .setFooter({ text: 'Mood changes based on time and interactions' });
    
    await message.reply({ embeds: [embed] });
  } catch (e) {
    await message.reply("*sighs* I'm fine. Stop asking.");
  }
}

async function handleRep(message, args) {
  try {
    const target = message.mentions.users.first() || message.author;
    
    // Try to get rep from database
    let rep = 50; // Default
    try {
      const result = await pool.query(
        'SELECT reputation FROM user_reputation WHERE user_id = $1',
        [target.id]
      );
      if (result.rows[0]) rep = result.rows[0].reputation;
    } catch (e) {
      // Table might not exist, use default
    }
    
    let status = 'Neutral';
    let color = 0xFFFF00;
    if (rep >= 80) { status = 'Excellent'; color = 0x00FF00; }
    else if (rep >= 60) { status = 'Good'; color = 0x88FF00; }
    else if (rep >= 40) { status = 'Neutral'; color = 0xFFFF00; }
    else if (rep >= 20) { status = 'Poor'; color = 0xFF8800; }
    else { status = 'Bad'; color = 0xFF0000; }
    
    const embed = new EmbedBuilder()
      .setTitle(`â­ ${target.username}'s Reputation`)
      .addFields(
        { name: 'Score', value: `${rep}/100`, inline: true },
        { name: 'Status', value: status, inline: true }
      )
      .setColor(color)
      .setFooter({ text: 'Complete LFGs to gain rep â€¢ Abandon to lose rep' });
    
    await message.reply({ embeds: [embed] });
  } catch (e) {
    await message.reply("*types* Can't pull up their record right now.");
  }
}

async function handleVoice(message, args) {
  if (!voiceSystem) return message.reply("Voice offline.");
  if (args[0] === 'join') { const vc = message.member.voice.channel; if (!vc) return message.reply("Get in a VC first."); const ok = await voiceChatHandler?.joinAndGreet(vc); message.reply(ok ? `ğŸ™ï¸ Joining ${vc.name}` : "Can't join."); }
  else if (args[0] === 'leave') { voiceSystem.leaveChannel(); message.reply("*disconnects*"); }
  else message.reply("`?voice join` or `?voice leave`");
}

async function handleSpeak(message, args) {
  if (!voiceSystem?.isConnected?.()) return message.reply("Use `?voice join` first.");
  const text = args.join(' '); if (!text) return message.reply("`?speak [text]`");
  try { const r = await anthropic.messages.create({ model: 'claude-sonnet-4-20250514', max_tokens: 100, system: LESTER_SYSTEM + '\nKeep SHORT.', messages: [{ role: 'user', content: text }] }); await voiceSystem.speak(r.content[0].text); message.reply(`ğŸ™ï¸ "${r.content[0].text}"`); } catch (e) { message.reply("Voice error."); }
}

async function handleStats(message, args) {
  if (!activityXP) return message.reply("Activity tracking not enabled.");
  
  const target = message.mentions.members.first() || message.member;
  
  try {
    const stats = await activityXP.getUserStats(target.id, message.guild.id, client);
    
    const embed = new EmbedBuilder()
      .setTitle(`ğŸ“Š ${target.user.username}'s Stats`)
      .addFields(
        { name: 'â­ XP', value: stats.xp.toLocaleString(), inline: true },
        { name: 'ğŸ’¬ Messages', value: stats.messages.toLocaleString(), inline: true },
        { name: 'ğŸ¤ Voice Hours', value: `${stats.voiceHours}h`, inline: true },
        { name: 'ğŸ‘ Reactions', value: stats.reactions.toLocaleString(), inline: true },
        { name: 'ğŸ”¥ Streak', value: `${stats.streak} days`, inline: true }
      )
      .setColor(0x00FF00)
      .setThumbnail(target.user.displayAvatarURL({ dynamic: true }))
      .setTimestamp();
    
    await message.reply({ embeds: [embed] });
  } catch (e) {
    await message.reply("*squints at screen* Can't find their stats.");
  }
}

async function handleLeaderboard(message, args) {
  if (!activityXP) return message.reply("Activity tracking not enabled.");
  
  const type = args[0] || 'xp';
  const validTypes = ['xp', 'messages', 'voice', 'reactions'];
  
  if (!validTypes.includes(type)) {
    return message.reply(`Valid types: ${validTypes.join(', ')}`);
  }
  
  try {
    const leaderboard = await activityXP.getLeaderboard(message.guild.id, type, 10, client);
    
    if (leaderboard.length === 0) {
      return message.reply("No data yet. Get chatting!");
    }
    
    let description = '';
    for (let i = 0; i < leaderboard.length; i++) {
      const entry = leaderboard[i];
      const member = await message.guild.members.fetch(entry.user_id).catch(() => null);
      const medal = i === 0 ? 'ğŸ¥‡' : i === 1 ? 'ğŸ¥ˆ' : i === 2 ? 'ğŸ¥‰' : `${i + 1}.`;
      const value = type === 'voice' ? `${Math.floor(entry.value / 60)}h` : parseInt(entry.value).toLocaleString();
      description += `${medal} **${member?.user.username || 'Unknown'}** - ${value}\n`;
    }
    
    const embed = new EmbedBuilder()
      .setTitle(`ğŸ“Š ${type.toUpperCase()} Leaderboard`)
      .setDescription(description)
      .setColor(0xFFD700)
      .setFooter({ text: 'Use ?lb [xp|messages|voice|reactions]' })
      .setTimestamp();
    
    await message.reply({ embeds: [embed] });
  } catch (e) {
    console.error('Leaderboard error:', e);
    await message.reply("*keyboard smashing* Leaderboard broke.");
  }
}

// ============================================
// FIX COUNTING CHANNEL
// ============================================
async function fixCountingChannel(message, client) {
  // Only owner/admin can use this
  if (!message.member.permissions.has('Administrator')) {
    return message.reply("You need Admin permissions to fix the counting channel.");
  }
  
  const COUNTING_CHANNEL_ID = '1453304735615418521';
  const THE_ONE_ROLE_ID = '1453304639578443940';
  
  try {
    // Get the counting channel
    let countingChannel = await client.channels.fetch(COUNTING_CHANNEL_ID).catch(() => null);
    
    if (!countingChannel) {
      countingChannel = message.guild.channels.cache.find(c => c.name === 'counting');
    }
    
    if (!countingChannel) {
      return message.reply("âŒ Could not find counting channel.");
    }
    
    await message.reply("ğŸ”§ Fixing counting channel...");
    
    // Delete all messages in the channel
    let deleted;
    do {
      deleted = await countingChannel.bulkDelete(100, true).catch(() => ({ size: 0 }));
    } while (deleted.size > 0);
    
    // Reset database
    await client.db.query(`
      DELETE FROM counting WHERE guild_id = $1
    `, [message.guild.id]);
    
    await client.db.query(`
      INSERT INTO counting (guild_id, current_count, last_counter, record)
      VALUES ($1, 0, NULL, 0)
    `, [message.guild.id]);
    
    // Remove The #1 role from everyone
    const theOneRole = message.guild.roles.cache.get(THE_ONE_ROLE_ID) || 
                       message.guild.roles.cache.find(r => r.name === 'ğŸ† The #1');
    if (theOneRole) {
      for (const [id, member] of theOneRole.members) {
        await member.roles.remove(theOneRole).catch(() => {});
      }
    }
    
    // Send fresh start message
    const startEmbed = new EmbedBuilder()
      .setTitle('ğŸ”¢ COUNTING GAME')
      .setDescription(`**How to play:**\nâ€¢ Count up from 1\nâ€¢ You can't count twice in a row\nâ€¢ If someone messes up, it resets to 1\n\n**The Prize:**\nğŸ† Whoever counts last holds **The #1** role!\n\n*Start counting from 1!*`)
      .setColor(0x00FF00)
      .setFooter({ text: 'Good luck!' })
      .setTimestamp();
    
    await countingChannel.send({ embeds: [startEmbed] });
    
    await message.channel.send(`âœ… Counting channel fixed! Head to <#${countingChannel.id}> and start from **1**!`);
    
  } catch (e) {
    console.error('Fix counting error:', e);
    await message.reply(`âŒ Error: ${e.message}`);
  }
}

// LOGGING EVENTS
client.on(Events.MessageDelete, async (m) => { try { await loggingHandler.messageDeleted(m, client); } catch (e) {} });
client.on(Events.MessageUpdate, async (o, n) => { try { await loggingHandler.messageEdited(o, n, client); } catch (e) {} });
client.on(Events.GuildMemberAdd, async (m) => { try { await loggingHandler.memberJoined(m, client); } catch (e) {} });
client.on(Events.GuildMemberRemove, async (m) => { try { await loggingHandler.memberLeft(m, client); } catch (e) {} });
client.on(Events.GuildBanAdd, async (b) => { try { await loggingHandler.memberBanned(b, client); } catch (e) {} });

// SERVER LOCK - Leave unauthorized servers immediately when added
client.on(Events.GuildCreate, async (guild) => {
  if (!isAuthorizedServer(guild.id)) {
    console.log(`[SECURITY] Bot added to unauthorized server: ${guild.name} (${guild.id}) - LEAVING IMMEDIATELY`);
    
    // Try to message the owner before leaving
    try {
      const owner = await guild.fetchOwner();
      await owner.send({
        embeds: [new EmbedBuilder()
          .setTitle('ğŸš« Unauthorized Server')
          .setDescription(
            `This bot is private and only operates in authorized servers.\n\n` +
            `**Your server:** ${guild.name}\n` +
            `**Status:** Not authorized\n\n` +
            `If you believe this is an error, contact the bot owner.\n\n` +
            `*This bot has left your server automatically.*`
          )
          .setColor(0xFF0000)
          .setTimestamp()
        ]
      });
    } catch (e) {}
    
    await guild.leave();
    return;
  }
  
  console.log(`[SECURITY] Bot added to authorized server: ${guild.name} (${guild.id})`);
});

client.on(Events.GuildMemberUpdate, async (o, n) => { 
  try { await loggingHandler.memberUpdated(o, n, client); } catch (e) {} 
  
  // Check if Inner Circle role was added
  try {
    const innerCircleRole = n.guild.roles.cache.find(r => r.name === 'â­ Inner Circle');
    if (!innerCircleRole) return;
    
    const hadRole = o.roles.cache.has(innerCircleRole.id);
    const hasRole = n.roles.cache.has(innerCircleRole.id);
    
    // Role was just added
    if (!hadRole && hasRole) {
      console.log(`[PREMIUM] ${n.user.tag} joined Inner Circle!`);
      
      // Send DM with onboarding
      const dmEmbed1 = new EmbedBuilder()
        .setTitle('â­ WELCOME TO THE INNER CIRCLE')
        .setDescription(
          `Hey ${n.user.username},\n\n` +
          `You're officially one of us now. This isn't just a subscriptionâ€”you're part of something exclusive.\n\n` +
          `**Here's what just unlocked for you:**`
        )
        .setColor(0xFFB300)
        .setThumbnail(n.guild.iconURL({ dynamic: true }));
      
      const dmEmbed2 = new EmbedBuilder()
        .setTitle('ğŸ”“ YOUR ACCESS')
        .setDescription(
          `ğŸ“œ **#confidential-agreement** - READ THIS FIRST\n` +
          `ğŸ’ **#vip-lounge** - Chill with fellow supporters\n` +
          `ğŸ¯ **#priority-lfg** - Skip the queue\n` +
          `ğŸ”® **#insider-intel** - Secret strats & early info\n` +
          `ğŸ™ï¸ **#vip-voice** - Private voice chat\n\n` +
          `**Bot Perks:**\n` +
          `â€¢ Bots remember you better\n` +
          `â€¢ Friendlier responses\n` +
          `â€¢ Priority in queues\n` +
          `â€¢ Early access to new features`
        )
        .setColor(0x00FF00);
      
      const dmEmbed3 = new EmbedBuilder()
        .setTitle('âš ï¸ IMPORTANT')
        .setDescription(
          `**This access is CONFIDENTIAL.**\n\n` +
          `â€¢ Don't screenshot or share content\n` +
          `â€¢ Don't share your account\n` +
          `â€¢ Don't leak insider info\n\n` +
          `Read the full terms in **#confidential-agreement**.\n\n` +
          `Violations = instant removal, no refund, blacklist.\n\n` +
          `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n` +
          `Questions? Ask in #vip-lounge.\n\n` +
          `*Welcome to the inside. Don't fuck it up.*\n\n` +
          `â€” The Unpatched Method`
        )
        .setColor(0xFF0000)
        .setFooter({ text: 'This message is confidential' })
        .setTimestamp();
      
      try {
        await n.user.send({ embeds: [dmEmbed1, dmEmbed2, dmEmbed3] });
      } catch (e) {
        // Can't DM user, post in lounge instead
        const loungeChannel = n.guild.channels.cache.find(c => c.name === 'ğŸ’ãƒ»vip-lounge');
        if (loungeChannel) {
          await loungeChannel.send({ 
            content: `${n} **Welcome to the Inner Circle!** Check out <#${n.guild.channels.cache.find(c => c.name === 'ğŸ“œãƒ»confidential-agreement')?.id}> first.`,
            embeds: [dmEmbed2] 
          });
        }
      }
      
      // Log to staff if there's a log channel
      const logChannel = n.guild.channels.cache.find(c => c.name.includes('premium-log') || c.name.includes('subscriber-log'));
      if (logChannel) {
        const logEmbed = new EmbedBuilder()
          .setTitle('ğŸ’° New Inner Circle Member')
          .setDescription(`**User:** ${n.user.tag} (${n.user.id})\n**Joined:** <t:${Math.floor(Date.now() / 1000)}:F>`)
          .setColor(0x00FF00)
          .setThumbnail(n.user.displayAvatarURL({ dynamic: true }))
          .setTimestamp();
        await logChannel.send({ embeds: [logEmbed] });
      }
    }
    
    // Role was removed
    if (hadRole && !hasRole) {
      console.log(`[PREMIUM] ${n.user.tag} left Inner Circle`);
      
      // Log removal
      const logChannel = n.guild.channels.cache.find(c => c.name.includes('premium-log') || c.name.includes('subscriber-log'));
      if (logChannel) {
        const logEmbed = new EmbedBuilder()
          .setTitle('ğŸ“¤ Inner Circle Member Left')
          .setDescription(`**User:** ${n.user.tag} (${n.user.id})\n**Left:** <t:${Math.floor(Date.now() / 1000)}:F>`)
          .setColor(0xFF0000)
          .setThumbnail(n.user.displayAvatarURL({ dynamic: true }))
          .setTimestamp();
        await logChannel.send({ embeds: [logEmbed] });
      }
    }
  } catch (e) {
    console.error('[PREMIUM] Role detection error:', e.message);
  }
});
client.on(Events.VoiceStateUpdate, async (o, n) => { 
  if (intelligence?.contextAwareness && n.guild) intelligence.contextAwareness.updateVoiceState(n.guild.id, n);
  try { await loggingHandler.voiceStateUpdate(o, n, client); } catch (e) {}
});
client.on(Events.MessageReactionAdd, async (r, u) => { if (u.bot) return; if (intelligence && r.message.author?.id === client.user.id) await intelligence.handleReaction(r.message.id, r.emoji.name, u.id); });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATS CATEGORY SETUP (with subscriber count)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function handleSetupStats(message) {
  if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
    return message.reply('âŒ Admin only.');
  }
  
  try {
    const guild = message.guild;
    
    // Delete old stats category if exists
    const oldCategory = guild.channels.cache.find(c => c.name === 'ğŸ“Š SERVER STATS' && c.type === 4);
    if (oldCategory) {
      for (const channel of oldCategory.children.cache.values()) {
        await channel.delete().catch(() => {});
      }
      await oldCategory.delete().catch(() => {});
    }
    
    // Create new category at the top
    const category = await guild.channels.create({
      name: 'ğŸ“Š SERVER STATS',
      type: 4, // Category
      position: 0
    });
    
    // Fetch members with presence
    await guild.members.fetch({ withPresences: true });
    
    const memberCount = guild.memberCount;
    let onlineCount = 0;
    for (const [id, member] of guild.members.cache) {
      if (member.user.bot) continue;
      const status = member.presence?.status;
      if (status === 'online' || status === 'idle' || status === 'dnd') {
        onlineCount++;
      }
    }
    const botCount = guild.members.cache.filter(m => m.user.bot).size;
    
    // Count Inner Circle members
    const innerCircleRole = guild.roles.cache.find(r => r.name === 'â­ Inner Circle');
    const subCount = innerCircleRole ? innerCircleRole.members.size : 0;
    
    // Create voice channels (locked so no one can join)
    const channelOptions = {
      type: 2, // Voice
      parent: category.id,
      permissionOverwrites: [
        {
          id: guild.id,
          deny: [PermissionFlagsBits.Connect]
        }
      ]
    };
    
    await guild.channels.create({ name: `ğŸ‘¥ Members: ${memberCount}`, ...channelOptions });
    await guild.channels.create({ name: `ğŸŸ¢ Online: ${onlineCount}`, ...channelOptions });
    await guild.channels.create({ name: `ğŸ¤– Bots: ${botCount}`, ...channelOptions });
    await guild.channels.create({ name: `â­ Subscribers: ${subCount}`, ...channelOptions });
    
    await message.reply(`âœ… **Stats category created!**\n\nğŸ“Š SERVER STATS\nâ”œ ğŸ‘¥ Members: ${memberCount}\nâ”œ ğŸŸ¢ Online: ${onlineCount}\nâ”œ ğŸ¤– Bots: ${botCount}\nâ”” â­ Subscribers: ${subCount}\n\n*Updates every 5 minutes automatically.*`);
    
  } catch (e) {
    console.error('Setup stats error:', e);
    await message.reply(`âŒ Error: ${e.message}`);
  }
}

async function handleDeleteStats(message) {
  if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
    return message.reply('âŒ Admin only.');
  }
  
  try {
    const guild = message.guild;
    const category = guild.channels.cache.find(c => c.name === 'ğŸ“Š SERVER STATS' && c.type === 4);
    
    if (!category) {
      return message.reply('âŒ No stats category found.');
    }
    
    for (const channel of category.children.cache.values()) {
      await channel.delete().catch(() => {});
    }
    await category.delete();
    
    await message.reply('âœ… Stats category deleted.');
    
  } catch (e) {
    console.error('Delete stats error:', e);
    await message.reply(`âŒ Error: ${e.message}`);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PREMIUM SETUP - Unique Subscriber System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function handleSetupPremium(message) {
  if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
    return message.reply('âŒ Admin only.');
  }
  
  try {
    const guild = message.guild;
    
    await message.reply('ğŸ”§ *accessing premium protocols...* Setting up the VIP system...');
    
    // Delete old premium stuff if exists
    const oldCategory = guild.channels.cache.find(c => c.name === 'â­ INNER CIRCLE' && c.type === 4);
    if (oldCategory) {
      for (const channel of oldCategory.children.cache.values()) {
        await channel.delete().catch(() => {});
      }
      await oldCategory.delete().catch(() => {});
    }
    
    const oldRole = guild.roles.cache.find(r => r.name === 'â­ Inner Circle');
    if (oldRole) await oldRole.delete().catch(() => {});
    
    // Create the premium role with unique gradient-like color
    // Using a deep gold/amber color: #FFB300
    const premiumRole = await guild.roles.create({
      name: 'â­ Inner Circle',
      color: 0xFFB300, // Deep gold/amber
      hoist: true, // Shows separately in member list
      mentionable: true,
      reason: 'Premium subscriber role'
    });
    
    // Move role high in hierarchy (below admin roles)
    const botRole = guild.members.me.roles.highest;
    await premiumRole.setPosition(botRole.position - 1).catch(() => {});
    
    // Create premium category
    const category = await guild.channels.create({
      name: 'â­ INNER CIRCLE',
      type: 4, // Category
      permissionOverwrites: [
        {
          id: guild.id, // @everyone
          deny: [PermissionFlagsBits.ViewChannel]
        },
        {
          id: premiumRole.id,
          allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.SendMessages, PermissionFlagsBits.Connect, PermissionFlagsBits.Speak]
        }
      ]
    });
    
    // Create RULES channel first (read-only)
    const rulesChannel = await guild.channels.create({
      name: 'ğŸ“œãƒ»confidential-agreement',
      type: 0, // Text
      parent: category.id,
      topic: 'âš ï¸ READ THIS FIRST. Confidentiality agreement and rules.',
      permissionOverwrites: [
        { id: guild.id, deny: [PermissionFlagsBits.ViewChannel] },
        { id: premiumRole.id, allow: [PermissionFlagsBits.ViewChannel], deny: [PermissionFlagsBits.SendMessages] }
      ]
    });
    
    // Post confidentiality agreement
    const confidentialEmbed1 = new EmbedBuilder()
      .setTitle('ğŸ”’ CONFIDENTIALITY AGREEMENT')
      .setDescription(`**Welcome to the Inner Circle.**\n\nBy accessing this section, you agree to the following terms. Violation results in **immediate removal** and potential **blacklist** from all Unpatched Method services.`)
      .setColor(0xFF0000)
      .setTimestamp();
    
    const confidentialEmbed2 = new EmbedBuilder()
      .setTitle('ğŸ“‹ TERMS OF ACCESS')
      .setDescription(
        `**1. NON-DISCLOSURE**\n` +
        `Everything in Inner Circle channels is **CONFIDENTIAL**. This includes:\n` +
        `â€¢ Strategies, glitches, and methods shared\n` +
        `â€¢ Insider intel and early updates\n` +
        `â€¢ Conversations and member identities\n` +
        `â€¢ Screenshots, recordings, or any reproduction\n\n` +
        `**2. NO SHARING**\n` +
        `â€¢ Do NOT screenshot or screen record\n` +
        `â€¢ Do NOT copy/paste content elsewhere\n` +
        `â€¢ Do NOT share your account access\n` +
        `â€¢ Do NOT invite others to "look around"\n\n` +
        `**3. NO RESELLING**\n` +
        `â€¢ Information here is for YOUR use only\n` +
        `â€¢ Reselling or redistributing = permanent ban\n` +
        `â€¢ We track leaks. We will find out.\n\n` +
        `**4. ACCOUNT SECURITY**\n` +
        `â€¢ YOU are responsible for your account\n` +
        `â€¢ Shared account = both users banned\n` +
        `â€¢ Compromised account = notify staff immediately`
      )
      .setColor(0xFF6600);
    
    const confidentialEmbed3 = new EmbedBuilder()
      .setTitle('âš ï¸ ENFORCEMENT')
      .setDescription(
        `**What happens if you break these rules:**\n\n` +
        `ğŸ”´ **First Offense:** Immediate removal, no refund\n` +
        `ğŸ”´ **Leak Detection:** Permanent blacklist + public shame\n` +
        `ğŸ”´ **Account Sharing:** Both accounts banned\n` +
        `ğŸ”´ **Chargeback Attempt:** Blacklisted from all future access\n\n` +
        `We have systems in place to detect leaks. Watermarked content, activity tracking, and more. Don't test us.\n\n` +
        `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n` +
        `âœ… **By staying in this server with the Inner Circle role, you acknowledge and agree to ALL terms above.**\n\n` +
        `*If you disagree, cancel your subscription now. No hard feelings.*`
      )
      .setColor(0xFF0000)
      .setFooter({ text: 'Inner Circle â€¢ Confidential â€¢ The Unpatched Method' });
    
    await rulesChannel.send({ embeds: [confidentialEmbed1] });
    await rulesChannel.send({ embeds: [confidentialEmbed2] });
    await rulesChannel.send({ embeds: [confidentialEmbed3] });
    
    // Create premium channels
    const loungeChannel = await guild.channels.create({
      name: 'ğŸ’ãƒ»vip-lounge',
      type: 0, // Text
      parent: category.id,
      topic: 'ğŸŒŸ Welcome to the Inner Circle. Exclusive access for our supporters.',
      permissionOverwrites: [
        { id: guild.id, deny: [PermissionFlagsBits.ViewChannel] },
        { id: premiumRole.id, allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.SendMessages] }
      ]
    });
    
    await guild.channels.create({
      name: 'ğŸ¯ãƒ»priority-lfg',
      type: 0, // Text
      parent: category.id,
      topic: 'âš¡ Priority matchmaking for Inner Circle members. Skip the queue.',
      permissionOverwrites: [
        { id: guild.id, deny: [PermissionFlagsBits.ViewChannel] },
        { id: premiumRole.id, allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.SendMessages] }
      ]
    });
    
    await guild.channels.create({
      name: 'ğŸ”®ãƒ»insider-intel',
      type: 0, // Text
      parent: category.id,
      topic: 'ğŸ¤« Early updates, secret strats, and insider information.',
      permissionOverwrites: [
        { id: guild.id, deny: [PermissionFlagsBits.ViewChannel] },
        { id: premiumRole.id, allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.SendMessages] }
      ]
    });
    
    await guild.channels.create({
      name: 'ğŸ™ï¸ãƒ»vip-voice',
      type: 2, // Voice
      parent: category.id,
      userLimit: 10,
      permissionOverwrites: [
        { id: guild.id, deny: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.Connect] },
        { id: premiumRole.id, allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.Connect, PermissionFlagsBits.Speak, PermissionFlagsBits.Stream] }
      ]
    });
    
    // Send welcome message in lounge
    const welcomeEmbed = new EmbedBuilder()
      .setTitle('â­ WELCOME TO THE INNER CIRCLE')
      .setDescription(`*The elite of The Unpatched Method.*\n\n` +
        `You've joined something special. This isn't just a subscriptionâ€”it's access to the inner workings.\n\n` +
        `**What you get:**\n` +
        `ğŸ’ **VIP Lounge** - Chill with fellow supporters\n` +
        `ğŸ¯ **Priority LFG** - Skip the queue, find crews faster\n` +
        `ğŸ”® **Insider Intel** - Early updates, secret strats\n` +
        `ğŸ™ï¸ **VIP Voice** - Private voice chat\n` +
        `âš¡ **Priority Support** - We see your messages first\n\n` +
        `*The bots remember their supporters. They treat you different.*`)
      .setColor(0xFFB300)
      .setFooter({ text: 'Inner Circle â€¢ The Unpatched Method' })
      .setTimestamp();
    
    await loungeChannel.send({ embeds: [welcomeEmbed] });
    
    // Final response
    const successEmbed = new EmbedBuilder()
      .setTitle('âœ… Premium System Activated')
      .setDescription(`*adjusts glasses* The Inner Circle is ready.\n\n` +
        `**Created:**\n` +
        `â­ Role: **Inner Circle** (${premiumRole})\n` +
        `ğŸ“ Category: **INNER CIRCLE**\n` +
        `ğŸ’ Channel: **#vip-lounge**\n` +
        `ğŸ¯ Channel: **#priority-lfg**\n` +
        `ğŸ”® Channel: **#insider-intel**\n` +
        `ğŸ™ï¸ Voice: **#vip-voice**\n\n` +
        `**Next steps:**\n` +
        `1. Go to Server Settings â†’ Server Products\n` +
        `2. Create a product that grants the **Inner Circle** role\n` +
        `3. Set your price\n` +
        `4. Members who buy get auto-assigned the role\n\n` +
        `*Now go make some money.*`)
      .setColor(0x00FF00)
      .setTimestamp();
    
    await message.reply({ embeds: [successEmbed] });
    
  } catch (e) {
    console.error('Premium setup error:', e);
    await message.reply(`âŒ Error: ${e.message}`);
  }
}

async function handleDeletePremium(message) {
  if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
    return message.reply('âŒ Admin only.');
  }
  
  try {
    const guild = message.guild;
    
    // Delete category and channels
    const category = guild.channels.cache.find(c => c.name === 'â­ INNER CIRCLE' && c.type === 4);
    if (category) {
      for (const channel of category.children.cache.values()) {
        await channel.delete().catch(() => {});
      }
      await category.delete().catch(() => {});
    }
    
    // Delete role
    const role = guild.roles.cache.find(r => r.name === 'â­ Inner Circle');
    if (role) await role.delete().catch(() => {});
    
    await message.reply('âœ… Premium system deleted. *Back to the basics.*');
    
  } catch (e) {
    console.error('Delete premium error:', e);
    await message.reply(`âŒ Error: ${e.message}`);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TERMS OF SERVICE SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function handleSetupTOS(message) {
  if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
    return message.reply('âŒ Admin only.');
  }
  
  try {
    const guild = message.guild;
    
    // Find or create rules/info category
    let infoCategory = guild.channels.cache.find(c => c.name.toLowerCase().includes('info') && c.type === 4);
    if (!infoCategory) {
      infoCategory = guild.channels.cache.find(c => c.name.toLowerCase().includes('rules') && c.type === 4);
    }
    
    // Create TOS channel
    const tosChannel = await guild.channels.create({
      name: 'ğŸ“œãƒ»terms-of-service',
      type: 0,
      parent: infoCategory?.id || null,
      topic: 'Terms of Service and Legal Information',
      permissionOverwrites: [
        { id: guild.id, allow: [PermissionFlagsBits.ViewChannel], deny: [PermissionFlagsBits.SendMessages] }
      ]
    });
    
    // Post TOS embeds
    const tosEmbed1 = new EmbedBuilder()
      .setTitle('ğŸ“œ TERMS OF SERVICE')
      .setDescription(
        `**THE UNPATCHED METHOD**\n` +
        `*Last Updated: ${new Date().toLocaleDateString()}*\n\n` +
        `By using this Discord server and its services, you agree to these terms. If you disagree, leave immediately.`
      )
      .setColor(0x2F3136);
    
    const tosEmbed2 = new EmbedBuilder()
      .setTitle('1. SERVICE DESCRIPTION')
      .setDescription(
        `**What We Provide:**\n` +
        `â€¢ Discord community for GTA Online & Red Dead Online\n` +
        `â€¢ AI-powered bot assistants\n` +
        `â€¢ Looking-for-group (LFG) matchmaking\n` +
        `â€¢ Premium subscription services (Inner Circle)\n` +
        `â€¢ Gaming strategies, tips, and information\n\n` +
        `**What We Don't Provide:**\n` +
        `â€¢ Guarantees of game account safety\n` +
        `â€¢ Official Rockstar Games support\n` +
        `â€¢ Refunds for digital purchases\n` +
        `â€¢ Legal advice or representation`
      )
      .setColor(0x2F3136);
    
    const tosEmbed3 = new EmbedBuilder()
      .setTitle('2. USER CONDUCT')
      .setDescription(
        `**You Agree To:**\n` +
        `â€¢ Follow Discord's Terms of Service\n` +
        `â€¢ Respect other members\n` +
        `â€¢ Not share premium content outside designated areas\n` +
        `â€¢ Not attempt to exploit, hack, or abuse our bots\n` +
        `â€¢ Not impersonate staff or other members\n` +
        `â€¢ Not spam, flood, or disrupt services\n` +
        `â€¢ Keep illegal content out of our server\n\n` +
        `**Violations Result In:**\n` +
        `â€¢ Warning â†’ Mute â†’ Kick â†’ Ban\n` +
        `â€¢ Severe violations = immediate permanent ban\n` +
        `â€¢ No appeals for chargebacks or payment fraud`
      )
      .setColor(0x2F3136);
    
    const tosEmbed4 = new EmbedBuilder()
      .setTitle('3. PREMIUM SERVICES')
      .setDescription(
        `**Inner Circle Subscriptions:**\n` +
        `â€¢ Payments processed by Discord/Stripe\n` +
        `â€¢ Access granted instantly upon payment\n` +
        `â€¢ **ALL SALES ARE FINAL - NO REFUNDS**\n` +
        `â€¢ Subscription auto-renews unless cancelled\n` +
        `â€¢ Cancellation removes access at period end\n\n` +
        `**Chargebacks & Fraud:**\n` +
        `â€¢ Chargeback attempts = permanent blacklist\n` +
        `â€¢ Fraudulent purchases reported to Discord\n` +
        `â€¢ We reserve right to pursue legal action\n\n` +
        `**Account Sharing:**\n` +
        `â€¢ Your subscription is for YOUR account only\n` +
        `â€¢ Sharing access = termination, no refund\n` +
        `â€¢ You are responsible for your account security`
      )
      .setColor(0xFF6600);
    
    const tosEmbed5 = new EmbedBuilder()
      .setTitle('4. INTELLECTUAL PROPERTY')
      .setDescription(
        `**Our Content:**\n` +
        `â€¢ Bot code, systems, and features are proprietary\n` +
        `â€¢ Server structure and setup are copyrighted\n` +
        `â€¢ Premium content is confidential\n` +
        `â€¢ Unauthorized reproduction is prohibited\n\n` +
        `**You May Not:**\n` +
        `â€¢ Copy, redistribute, or sell our bot code\n` +
        `â€¢ Screenshot/record premium content for sharing\n` +
        `â€¢ Reverse engineer our systems\n` +
        `â€¢ Create derivative works without permission\n\n` +
        `**DMCA:**\n` +
        `We will pursue DMCA takedowns and legal action against IP theft.`
      )
      .setColor(0xFF0000);
    
    const tosEmbed6 = new EmbedBuilder()
      .setTitle('5. DISCLAIMERS')
      .setDescription(
        `**As-Is Service:**\n` +
        `â€¢ Services provided "AS IS" without warranty\n` +
        `â€¢ We don't guarantee uptime or availability\n` +
        `â€¢ Bot features may change without notice\n` +
        `â€¢ We're not responsible for game bans\n\n` +
        `**Limitation of Liability:**\n` +
        `â€¢ Maximum liability = amount you paid us\n` +
        `â€¢ We're not liable for indirect damages\n` +
        `â€¢ Use glitches/exploits at your own risk\n\n` +
        `**Third Parties:**\n` +
        `â€¢ We're not affiliated with Rockstar Games\n` +
        `â€¢ We're not responsible for third-party content\n` +
        `â€¢ External links are used at your own risk`
      )
      .setColor(0x2F3136);
    
    const tosEmbed7 = new EmbedBuilder()
      .setTitle('6. TERMINATION')
      .setDescription(
        `**We May Terminate Your Access If:**\n` +
        `â€¢ You violate these terms\n` +
        `â€¢ You engage in fraud or chargebacks\n` +
        `â€¢ You harass staff or members\n` +
        `â€¢ You damage our reputation\n` +
        `â€¢ At our sole discretion\n\n` +
        `**Upon Termination:**\n` +
        `â€¢ No refund of subscription fees\n` +
        `â€¢ All access revoked immediately\n` +
        `â€¢ Blacklist from future services\n` +
        `â€¢ Data may be retained for legal purposes`
      )
      .setColor(0xFF0000);
    
    const tosEmbed8 = new EmbedBuilder()
      .setTitle('7. AGREEMENT')
      .setDescription(
        `**By Remaining In This Server:**\n\n` +
        `âœ… You confirm you are 13+ years old\n` +
        `âœ… You agree to all terms above\n` +
        `âœ… You accept our privacy practices\n` +
        `âœ… You understand purchases are final\n` +
        `âœ… You accept our right to modify terms\n\n` +
        `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n` +
        `**Contact:** Server staff for questions\n` +
        `**Disputes:** Handled via Discord support\n\n` +
        `*These terms may be updated. Continued use = acceptance.*\n\n` +
        `Â© ${new Date().getFullYear()} The Unpatched Method. All rights reserved.`
      )
      .setColor(0x00FF00)
      .setFooter({ text: 'Terms of Service â€¢ The Unpatched Method' })
      .setTimestamp();
    
    await tosChannel.send({ embeds: [tosEmbed1] });
    await tosChannel.send({ embeds: [tosEmbed2] });
    await tosChannel.send({ embeds: [tosEmbed3] });
    await tosChannel.send({ embeds: [tosEmbed4] });
    await tosChannel.send({ embeds: [tosEmbed5] });
    await tosChannel.send({ embeds: [tosEmbed6] });
    await tosChannel.send({ embeds: [tosEmbed7] });
    await tosChannel.send({ embeds: [tosEmbed8] });
    
    await message.reply(`âœ… **Terms of Service created!**\n\nChannel: ${tosChannel}\n\n*Professional TOS protects you legally.*`);
    
  } catch (e) {
    console.error('TOS setup error:', e);
    await message.reply(`âŒ Error: ${e.message}`);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TESTIMONIAL SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function handleTestimonial(message, args) {
  // Check if user is Inner Circle
  const innerCircleRole = message.guild.roles.cache.find(r => r.name === 'â­ Inner Circle');
  if (!innerCircleRole || !message.member.roles.cache.has(innerCircleRole.id)) {
    return message.reply('âŒ Only Inner Circle members can leave testimonials.');
  }
  
  const review = args.join(' ');
  if (!review || review.length < 10) {
    return message.reply('âŒ Usage: `?testimonial Your review here (at least 10 characters)`');
  }
  
  if (review.length > 500) {
    return message.reply('âŒ Keep it under 500 characters.');
  }
  
  // Find or create testimonials channel
  let testimonialsChannel = message.guild.channels.cache.find(c => c.name === 'â­ãƒ»testimonials');
  
  if (!testimonialsChannel) {
    // Create it
    testimonialsChannel = await message.guild.channels.create({
      name: 'â­ãƒ»testimonials',
      type: 0,
      topic: 'ğŸ’¬ Reviews from Inner Circle members. Real people, real experiences.',
      permissionOverwrites: [
        { id: message.guild.id, allow: [PermissionFlagsBits.ViewChannel], deny: [PermissionFlagsBits.SendMessages] }
      ]
    });
    
    // Post header
    const headerEmbed = new EmbedBuilder()
      .setTitle('â­ INNER CIRCLE TESTIMONIALS')
      .setDescription(
        `**Real reviews from real members.**\n\n` +
        `These are testimonials from our Inner Circle subscribers. Unedited, unfiltered.\n\n` +
        `*Want to leave a review? Subscribe to Inner Circle and use \`?testimonial\` in any channel.*`
      )
      .setColor(0xFFB300)
      .setTimestamp();
    
    await testimonialsChannel.send({ embeds: [headerEmbed] });
  }
  
  // Create testimonial embed
  const stars = 'â­'.repeat(5); // 5 stars default
  const testimonialEmbed = new EmbedBuilder()
    .setAuthor({ 
      name: message.author.username, 
      iconURL: message.author.displayAvatarURL({ dynamic: true }) 
    })
    .setDescription(`"${review}"`)
    .addFields(
      { name: 'Rating', value: stars, inline: true },
      { name: 'Member Since', value: `<t:${Math.floor(message.member.joinedTimestamp / 1000)}:R>`, inline: true }
    )
    .setColor(0xFFB300)
    .setFooter({ text: 'Inner Circle Member' })
    .setTimestamp();
  
  await testimonialsChannel.send({ embeds: [testimonialEmbed] });
  await message.reply(`âœ… **Testimonial posted!** Thanks for the review. Check it out in ${testimonialsChannel}`);
  
  // Delete original message to keep it clean
  await message.delete().catch(() => {});
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PREMIUM TIERS SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function handleSetupTiers(message) {
  if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
    return message.reply('âŒ Admin only.');
  }
  
  try {
    const guild = message.guild;
    
    await message.reply('ğŸ”§ *configuring premium tiers...* Setting up multiple subscription levels...');
    
    // Create three tiers
    const tier1Role = await guild.roles.create({
      name: 'â­ Inner Circle',
      color: 0xFFB300, // Gold
      hoist: true,
      mentionable: true,
      reason: 'Premium Tier 1'
    }).catch(() => guild.roles.cache.find(r => r.name === 'â­ Inner Circle'));
    
    const tier2Role = await guild.roles.create({
      name: 'ğŸ’ Inner Circle+',
      color: 0x00FFFF, // Cyan/Diamond
      hoist: true,
      mentionable: true,
      reason: 'Premium Tier 2'
    });
    
    const tier3Role = await guild.roles.create({
      name: 'ğŸ‘‘ Lifetime VIP',
      color: 0xFF00FF, // Purple/Royal
      hoist: true,
      mentionable: true,
      reason: 'Premium Tier 3 - Lifetime'
    });
    
    // Move roles high
    const botRole = guild.members.me.roles.highest;
    await tier3Role.setPosition(botRole.position - 1).catch(() => {});
    await tier2Role.setPosition(botRole.position - 2).catch(() => {});
    await tier1Role.setPosition(botRole.position - 3).catch(() => {});
    
    // Find or create premium info channel
    let premiumInfoChannel = guild.channels.cache.find(c => c.name === 'ğŸ’°ãƒ»premium-info');
    if (!premiumInfoChannel) {
      premiumInfoChannel = await guild.channels.create({
        name: 'ğŸ’°ãƒ»premium-info',
        type: 0,
        topic: 'Information about our premium tiers and benefits'
      });
    }
    
    // Clear old messages
    const oldMessages = await premiumInfoChannel.messages.fetch({ limit: 50 });
    await premiumInfoChannel.bulkDelete(oldMessages).catch(() => {});
    
    // Post tier info
    const headerEmbed = new EmbedBuilder()
      .setTitle('ğŸ’ PREMIUM MEMBERSHIPS')
      .setDescription(
        `**Support The Unpatched Method and get exclusive perks.**\n\n` +
        `Choose the tier that fits you. All tiers support our community and development.`
      )
      .setColor(0xFFB300)
      .setImage('https://i.imgur.com/your-banner-here.png'); // You can add a banner
    
    const tier1Embed = new EmbedBuilder()
      .setTitle('â­ INNER CIRCLE')
      .setDescription(
        `**$4.99/month**\n\n` +
        `The standard premium experience.\n\n` +
        `**Includes:**\n` +
        `âœ… Access to all premium channels\n` +
        `âœ… Priority LFG matchmaking\n` +
        `âœ… Insider intel & early updates\n` +
        `âœ… VIP voice chat\n` +
        `âœ… Bots remember you better\n` +
        `âœ… Subscriber role & badge\n` +
        `âœ… Support the community`
      )
      .setColor(0xFFB300)
      .setFooter({ text: 'Monthly subscription â€¢ Cancel anytime' });
    
    const tier2Embed = new EmbedBuilder()
      .setTitle('ğŸ’ INNER CIRCLE+')
      .setDescription(
        `**$9.99/month**\n\n` +
        `Everything in Inner Circle, plus more.\n\n` +
        `**Includes Everything Above, Plus:**\n` +
        `âœ… Direct message support from staff\n` +
        `âœ… Custom bot nickname recognition\n` +
        `âœ… Early access to new features\n` +
        `âœ… Vote on upcoming features\n` +
        `âœ… Exclusive giveaway entries\n` +
        `âœ… Diamond role & badge\n` +
        `âœ… Priority support queue`
      )
      .setColor(0x00FFFF)
      .setFooter({ text: 'Monthly subscription â€¢ Best value' });
    
    const tier3Embed = new EmbedBuilder()
      .setTitle('ğŸ‘‘ LIFETIME VIP')
      .setDescription(
        `**$49.99 one-time**\n\n` +
        `Pay once, VIP forever.\n\n` +
        `**Includes Everything Above, Plus:**\n` +
        `âœ… LIFETIME access (never expires)\n` +
        `âœ… Name in credits/about section\n` +
        `âœ… Custom role color (request)\n` +
        `âœ… Direct line to owner\n` +
        `âœ… Beta test new bots/features\n` +
        `âœ… Crown role & badge\n` +
        `âœ… Our eternal gratitude ğŸ‘‘`
      )
      .setColor(0xFF00FF)
      .setFooter({ text: 'One-time payment â€¢ Lifetime access' });
    
    const howToEmbed = new EmbedBuilder()
      .setTitle('ğŸ›’ HOW TO SUBSCRIBE')
      .setDescription(
        `**Getting your premium access is easy:**\n\n` +
        `1ï¸âƒ£ Click **Server Settings** (server name â†’ dropdown)\n` +
        `2ï¸âƒ£ Click **Server Subscriptions** or **Shop**\n` +
        `3ï¸âƒ£ Choose your tier\n` +
        `4ï¸âƒ£ Complete payment via Discord\n` +
        `5ï¸âƒ£ Access granted instantly!\n\n` +
        `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n` +
        `**Payment Methods:**\n` +
        `ğŸ’³ Credit/Debit Card\n` +
        `ğŸ“± PayPal\n` +
        `ğŸ® Discord Nitro Credits\n\n` +
        `**Questions?** Ask in general chat or DM staff.`
      )
      .setColor(0x00FF00);
    
    await premiumInfoChannel.send({ embeds: [headerEmbed] });
    await premiumInfoChannel.send({ embeds: [tier1Embed] });
    await premiumInfoChannel.send({ embeds: [tier2Embed] });
    await premiumInfoChannel.send({ embeds: [tier3Embed] });
    await premiumInfoChannel.send({ embeds: [howToEmbed] });
    
    const successEmbed = new EmbedBuilder()
      .setTitle('âœ… Premium Tiers Created')
      .setDescription(
        `**Roles Created:**\n` +
        `â­ Inner Circle - $4.99/mo\n` +
        `ğŸ’ Inner Circle+ - $9.99/mo\n` +
        `ğŸ‘‘ Lifetime VIP - $49.99 once\n\n` +
        `**Info Channel:** ${premiumInfoChannel}\n\n` +
        `**Next Steps:**\n` +
        `1. Go to Server Settings â†’ Server Products\n` +
        `2. Create 3 products (one per tier)\n` +
        `3. Assign each role to its product\n` +
        `4. Set the prices\n` +
        `5. Publish!`
      )
      .setColor(0x00FF00)
      .setTimestamp();
    
    await message.reply({ embeds: [successEmbed] });
    
  } catch (e) {
    console.error('Tiers setup error:', e);
    await message.reply(`âŒ Error: ${e.message}`);
  }
}

async function handleDeleteTiers(message) {
  if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
    return message.reply('âŒ Admin only.');
  }
  
  try {
    const guild = message.guild;
    
    // Delete tier roles (except base Inner Circle which deletepremium handles)
    const tier2 = guild.roles.cache.find(r => r.name === 'ğŸ’ Inner Circle+');
    const tier3 = guild.roles.cache.find(r => r.name === 'ğŸ‘‘ Lifetime VIP');
    
    if (tier2) await tier2.delete().catch(() => {});
    if (tier3) await tier3.delete().catch(() => {});
    
    // Delete premium info channel
    const infoChannel = guild.channels.cache.find(c => c.name === 'ğŸ’°ãƒ»premium-info');
    if (infoChannel) await infoChannel.delete().catch(() => {});
    
    await message.reply('âœ… Premium tiers deleted (kept base Inner Circle role).');
    
  } catch (e) {
    console.error('Delete tiers error:', e);
    await message.reply(`âŒ Error: ${e.message}`);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BLACKLIST SYSTEM (for payment abusers)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function handleBlacklist(message, args) {
  if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
    return message.reply('âŒ Admin only.');
  }
  
  const userId = args[0]?.replace(/[<@!>]/g, '');
  const reason = args.slice(1).join(' ') || 'No reason provided';
  
  if (!userId) {
    return message.reply('âŒ Usage: `?blacklist @user reason`');
  }
  
  try {
    // Store in database
    await client.db.query(`
      INSERT INTO blacklist (user_id, guild_id, reason, blacklisted_by, created_at)
      VALUES ($1, $2, $3, $4, NOW())
      ON CONFLICT (user_id, guild_id) DO UPDATE SET reason = $3, blacklisted_by = $4, created_at = NOW()
    `, [userId, message.guild.id, reason, message.author.id]);
    
    // Create blacklist role if doesn't exist
    let blacklistRole = message.guild.roles.cache.find(r => r.name === 'ğŸš« Blacklisted');
    if (!blacklistRole) {
      blacklistRole = await message.guild.roles.create({
        name: 'ğŸš« Blacklisted',
        color: 0x000000,
        permissions: [],
        reason: 'Blacklist role for payment abusers'
      });
    }
    
    // Apply role if member is in server
    const member = await message.guild.members.fetch(userId).catch(() => null);
    if (member) {
      await member.roles.add(blacklistRole);
      
      // Remove any premium roles
      const premiumRoles = ['â­ Inner Circle', 'ğŸ’ Inner Circle+', 'ğŸ‘‘ Lifetime VIP'];
      for (const roleName of premiumRoles) {
        const role = message.guild.roles.cache.find(r => r.name === roleName);
        if (role && member.roles.cache.has(role.id)) {
          await member.roles.remove(role);
        }
      }
      
      // DM them
      try {
        await member.send({
          embeds: [new EmbedBuilder()
            .setTitle('ğŸš« You Have Been Blacklisted')
            .setDescription(
              `You have been blacklisted from The Unpatched Method.\n\n` +
              `**Reason:** ${reason}\n\n` +
              `This means:\n` +
              `â€¢ You cannot purchase premium services\n` +
              `â€¢ Any existing access has been revoked\n` +
              `â€¢ This is permanent\n\n` +
              `If you believe this is an error, contact server staff.`
            )
            .setColor(0xFF0000)
            .setTimestamp()
          ]
        });
      } catch (e) {}
    }
    
    // Log it
    const logChannel = message.guild.channels.cache.find(c => 
      c.name.includes('premium-log') || c.name.includes('blacklist-log') || c.name.includes('mod-log')
    );
    
    if (logChannel) {
      const logEmbed = new EmbedBuilder()
        .setTitle('ğŸš« User Blacklisted')
        .setDescription(
          `**User:** <@${userId}> (${userId})\n` +
          `**Reason:** ${reason}\n` +
          `**By:** ${message.author}\n` +
          `**Time:** <t:${Math.floor(Date.now() / 1000)}:F>`
        )
        .setColor(0xFF0000)
        .setTimestamp();
      
      await logChannel.send({ embeds: [logEmbed] });
    }
    
    await message.reply(`âœ… **User blacklisted.**\n\nUser: <@${userId}>\nReason: ${reason}\n\n*They cannot purchase premium services.*`);
    
  } catch (e) {
    console.error('Blacklist error:', e);
    await message.reply(`âŒ Error: ${e.message}`);
  }
}

async function handleUnblacklist(message, args) {
  if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
    return message.reply('âŒ Admin only.');
  }
  
  const userId = args[0]?.replace(/[<@!>]/g, '');
  
  if (!userId) {
    return message.reply('âŒ Usage: `?unblacklist @user`');
  }
  
  try {
    // Remove from database
    await client.db.query(`
      DELETE FROM blacklist WHERE user_id = $1 AND guild_id = $2
    `, [userId, message.guild.id]);
    
    // Remove role if member is in server
    const member = await message.guild.members.fetch(userId).catch(() => null);
    if (member) {
      const blacklistRole = message.guild.roles.cache.find(r => r.name === 'ğŸš« Blacklisted');
      if (blacklistRole && member.roles.cache.has(blacklistRole.id)) {
        await member.roles.remove(blacklistRole);
      }
    }
    
    await message.reply(`âœ… <@${userId}> has been removed from the blacklist.`);
    
  } catch (e) {
    console.error('Unblacklist error:', e);
    await message.reply(`âŒ Error: ${e.message}`);
  }
}

async function handleBlacklistCheck(message, args) {
  const userId = args[0]?.replace(/[<@!>]/g, '') || message.author.id;
  
  try {
    const result = await client.db.query(`
      SELECT * FROM blacklist WHERE user_id = $1 AND guild_id = $2
    `, [userId, message.guild.id]);
    
    if (result.rows.length > 0) {
      const entry = result.rows[0];
      const embed = new EmbedBuilder()
        .setTitle('ğŸš« Blacklist Entry Found')
        .setDescription(
          `**User:** <@${userId}>\n` +
          `**Reason:** ${entry.reason}\n` +
          `**Blacklisted:** <t:${Math.floor(new Date(entry.created_at).getTime() / 1000)}:R>\n` +
          `**By:** <@${entry.blacklisted_by}>`
        )
        .setColor(0xFF0000);
      
      await message.reply({ embeds: [embed] });
    } else {
      await message.reply(`âœ… <@${userId}> is NOT blacklisted.`);
    }
    
  } catch (e) {
    console.error('Blacklist check error:', e);
    await message.reply(`âŒ Error: ${e.message}`);
  }
}

// Prevent blacklisted users from getting premium roles
client.on(Events.GuildMemberUpdate, async (oldMember, newMember) => {
  try {
    // Check if they gained a premium role
    const premiumRoleNames = ['â­ Inner Circle', 'ğŸ’ Inner Circle+', 'ğŸ‘‘ Lifetime VIP'];
    
    for (const roleName of premiumRoleNames) {
      const role = newMember.guild.roles.cache.find(r => r.name === roleName);
      if (!role) continue;
      
      const hadRole = oldMember.roles.cache.has(role.id);
      const hasRole = newMember.roles.cache.has(role.id);
      
      if (!hadRole && hasRole) {
        // They just got a premium role - check blacklist
        const result = await client.db.query(`
          SELECT * FROM blacklist WHERE user_id = $1 AND guild_id = $2
        `, [newMember.id, newMember.guild.id]);
        
        if (result.rows.length > 0) {
          // They're blacklisted! Remove the role immediately
          await newMember.roles.remove(role);
          
          // DM them
          try {
            await newMember.send({
              embeds: [new EmbedBuilder()
                .setTitle('ğŸš« Access Denied')
                .setDescription(
                  `Your purchase was blocked because you are blacklisted.\n\n` +
                  `**Reason:** ${result.rows[0].reason}\n\n` +
                  `Your payment will be refunded by Discord. You cannot access premium services.`
                )
                .setColor(0xFF0000)
              ]
            });
          } catch (e) {}
          
          // Log it
          const logChannel = newMember.guild.channels.cache.find(c => 
            c.name.includes('premium-log') || c.name.includes('blacklist-log')
          );
          
          if (logChannel) {
            await logChannel.send({
              embeds: [new EmbedBuilder()
                .setTitle('ğŸš« Blacklisted User Attempted Purchase')
                .setDescription(
                  `**User:** ${newMember.user.tag} (${newMember.id})\n` +
                  `**Attempted Role:** ${roleName}\n` +
                  `**Action:** Role removed automatically\n` +
                  `**Blacklist Reason:** ${result.rows[0].reason}`
                )
                .setColor(0xFF0000)
                .setTimestamp()
              ]
            });
          }
        }
      }
    }
  } catch (e) {
    console.error('Blacklist role check error:', e.message);
  }
});

client.on('error', console.error);
process.on('unhandledRejection', console.error);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ECONOMY SYSTEM HANDLERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function handleBalance(message) {
  if (!economy) return message.reply('Economy system not loaded.');
  const account = await economy.getAccount(message.author.id, message.guild.id);
  const embed = economy.createBalanceEmbed(account, message.author);
  await message.reply({ embeds: [embed] });
}

async function handleDaily(message) {
  if (!economy) return message.reply('Economy system not loaded.');
  const result = await economy.claimDaily(message.author.id, message.guild.id);
  if (!result.success) return message.reply(result.message);
  
  const embed = new EmbedBuilder()
    .setTitle('ğŸ’° Daily Reward!')
    .setDescription(`You claimed **${economy.currency.symbol} ${result.reward.toLocaleString()}**!`)
    .addFields(
      { name: 'ğŸ”¥ Streak', value: `${result.streak} days`, inline: true },
      { name: 'â• Streak Bonus', value: `${economy.currency.symbol} ${result.streakBonus}`, inline: true }
    )
    .setColor(0x00FF00)
    .setFooter({ text: 'Come back tomorrow for more!' });
  await message.reply({ embeds: [embed] });
}

async function handleWork(message) {
  if (!economy) return message.reply('Economy system not loaded.');
  const result = await economy.work(message.author.id, message.guild.id);
  if (!result.success) return message.reply(result.message);
  
  await message.reply(`ğŸ’¼ You ${result.job} and earned **${economy.currency.symbol} ${result.earnings.toLocaleString()}**!`);
}

async function handleCrime(message) {
  if (!economy) return message.reply('Economy system not loaded.');
  const result = await economy.crime(message.author.id, message.guild.id);
  if (!result.success) return message.reply(result.message);
  
  if (result.caught) {
    await message.reply(`ğŸš” You tried to ${result.crime} but got caught! Paid **${economy.currency.symbol} ${result.fine}** in fines.`);
  } else {
    await message.reply(`ğŸ¦¹ You successfully ${result.crime} and scored **${economy.currency.symbol} ${result.earnings.toLocaleString()}**!`);
  }
}

async function handleSlots(message, args) {
  if (!economy) return message.reply('Economy system not loaded.');
  const bet = parseInt(args[0]) || 100;
  const result = await economy.playSlots(message.author.id, message.guild.id, bet);
  if (!result.success) return message.reply(result.message);
  
  const embed = economy.createSlotsEmbed(result, message.author);
  await message.reply({ embeds: [embed] });
}

async function handleCoinflip(message, args) {
  if (!economy) return message.reply('Economy system not loaded.');
  const bet = parseInt(args[0]) || 100;
  const choice = args[1] || 'heads';
  const result = await economy.coinflip(message.author.id, message.guild.id, bet, choice);
  if (!result.success) return message.reply(result.message);
  
  const coinEmoji = result.result === 'heads' ? 'ğŸª™' : 'â­•';
  if (result.won) {
    await message.reply(`${coinEmoji} **${result.result.toUpperCase()}!** You won **${economy.currency.symbol} ${result.profit.toLocaleString()}**!`);
  } else {
    await message.reply(`${coinEmoji} **${result.result.toUpperCase()}!** You lost **${economy.currency.symbol} ${result.loss.toLocaleString()}**`);
  }
}

async function handleBlackjack(message, args) {
  if (!economy) return message.reply('Economy system not loaded.');
  const bet = parseInt(args[0]) || 100;
  const result = await economy.blackjack(message.author.id, message.guild.id, bet);
  if (!result.success) return message.reply(result.message);
  
  const embed = new EmbedBuilder()
    .setTitle('ğŸƒ Blackjack')
    .addFields(
      { name: 'Your Hand', value: `${result.playerHand.join(' ')} (${result.playerTotal})`, inline: true },
      { name: 'Dealer Hand', value: `${result.dealerHand.join(' ')} (${result.dealerTotal})`, inline: true }
    )
    .setColor(result.won ? 0x00FF00 : result.push ? 0xFFFF00 : 0xFF0000)
    .setFooter({ text: result.blackjack ? 'BLACKJACK!' : result.push ? 'Push - bet returned' : result.won ? 'You win!' : 'Dealer wins' });
  
  if (result.won || result.push) {
    embed.addFields({ name: 'ğŸ’° Payout', value: `${economy.currency.symbol} ${result.winnings.toLocaleString()}` });
  }
  await message.reply({ embeds: [embed] });
}

async function handleRoulette(message, args) {
  if (!economy) return message.reply('Economy system not loaded.');
  const bet = parseInt(args[0]) || 100;
  const choice = args.slice(1).join(' ') || 'red';
  const result = await economy.roulette(message.author.id, message.guild.id, bet, choice);
  if (!result.success) return message.reply(result.message);
  
  const embed = new EmbedBuilder()
    .setTitle('ğŸ° Roulette')
    .setDescription(`The ball lands on... **${result.color} ${result.result}**!`)
    .addFields(
      { name: 'Your Bet', value: `${result.betType}`, inline: true },
      { name: 'Result', value: result.won ? `ğŸ‰ WIN! ${result.multiplier}x` : 'âŒ Loss', inline: true }
    )
    .setColor(result.won ? 0x00FF00 : 0xFF0000);
  
  if (result.won) embed.addFields({ name: 'ğŸ’° Winnings', value: `${economy.currency.symbol} ${result.winnings.toLocaleString()}` });
  await message.reply({ embeds: [embed] });
}

async function handlePay(message, args) {
  if (!economy) return message.reply('Economy system not loaded.');
  const target = message.mentions.users.first();
  if (!target) return message.reply('Mention someone to pay!');
  const amount = parseInt(args[1]) || parseInt(args[0]?.replace(/[<@!>]/g, ''));
  if (!amount || amount < 1) return message.reply('Enter a valid amount!');
  
  const result = await economy.transfer(message.author.id, target.id, message.guild.id, amount);
  if (!result.success) return message.reply(result.message);
  
  await message.reply(`âœ… Sent **${economy.currency.symbol} ${amount.toLocaleString()}** to ${target}!`);
}

async function handleRichest(message) {
  if (!economy) return message.reply('Economy system not loaded.');
  const leaderboard = await economy.getLeaderboard(message.guild.id, 'balance', 10);
  const embed = economy.createLeaderboardEmbed(leaderboard, message.guild, 'balance');
  await message.reply({ embeds: [embed] });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HEIST PLANNER HANDLERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function handlePlan(message, args) {
  if (!heistPlanner) return message.reply('Heist planner not loaded.');
  const time = parseInt(args[0]) || 60;
  const players = parseInt(args[1]) || 1;
  const game = args[2]?.toLowerCase() === 'rdo' ? 'rdo' : 'gta';
  
  const plan = await heistPlanner.generatePlan(time, players, game);
  const embed = heistPlanner.createPlanEmbed(plan, time, game);
  await message.reply({ embeds: [embed] });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REPUTATION HANDLERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function handleReputation(message, args) {
  if (!reputation) return message.reply('Reputation system not loaded.');
  const target = message.mentions.users.first() || message.author;
  const rep = await reputation.getReputation(target.id, message.guild.id);
  const partners = await reputation.getFrequentPartners(target.id, message.guild.id, 5);
  const embed = reputation.createReputationEmbed(rep, target, partners);
  await message.reply({ embeds: [embed] });
}

async function handleRate(message, args) {
  if (!reputation) return message.reply('Reputation system not loaded.');
  const target = message.mentions.users.first();
  if (!target) return message.reply('Mention someone to rate!');
  const rating = parseInt(args[1]) || parseInt(args.find(a => !a.startsWith('<@')));
  if (!rating || rating < 1 || rating > 5) return message.reply('Rate 1-5 stars! Example: `?rate @user 5`');
  
  const result = await reputation.ratePlayer(message.author.id, target.id, message.guild.id, rating);
  if (!result.success) return message.reply(result.message);
  
  await message.reply(`â­ Rated ${target} **${rating}/5** stars! Their new average: **${result.newAverage}/5**`);
}

async function handlePartners(message) {
  if (!reputation) return message.reply('Reputation system not loaded.');
  const partners = await reputation.getFrequentPartners(message.author.id, message.guild.id, 10);
  
  if (partners.length === 0) return message.reply("You haven't played with anyone yet!");
  
  const partnerList = partners.map((p, i) => 
    `${i + 1}. <@${p.partner_id}> - **${p.sessions_together}** sessions | $${parseInt(p.total_earnings_together).toLocaleString()} earned together`
  ).join('\n');
  
  const embed = new EmbedBuilder()
    .setTitle('ğŸ¤ Your Frequent Partners')
    .setDescription(partnerList)
    .setColor(0x00BFFF);
  await message.reply({ embeds: [embed] });
}

async function handleConnection(message, args) {
  if (!reputation) return message.reply('Reputation system not loaded.');
  const target = message.mentions.users.first();
  if (!target) return message.reply('Mention someone to see your connection!');
  
  const connection = await reputation.getConnection(message.author.id, target.id, message.guild.id);
  const embed = reputation.createConnectionEmbed(connection, message.author, target);
  await message.reply({ embeds: [embed] });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PREDICTIVE ANALYTICS HANDLERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function handleMyTime(message) {
  if (!predictive) return message.reply('Predictive analytics not loaded.');
  const prediction = await predictive.predictBestTime(message.author.id, message.guild.id);
  const serverPeaks = await predictive.getServerPeakTimes(message.guild.id, 3);
  const embed = predictive.createPredictionEmbed(prediction, message.author, serverPeaks);
  await message.reply({ embeds: [embed] });
}

async function handlePeakTimes(message) {
  if (!predictive) return message.reply('Predictive analytics not loaded.');
  const peaks = await predictive.getServerPeakTimes(message.guild.id, 10);
  
  if (peaks.length === 0) return message.reply('Not enough data yet!');
  
  const peakList = peaks.map((p, i) => 
    `${i + 1}. **${predictive.getDayName(p.day_of_week)}** at **${predictive.formatHour(p.hour_of_day)}** - ${p.total_lfg} sessions`
  ).join('\n');
  
  const embed = new EmbedBuilder()
    .setTitle('ğŸŒ Server Peak Times')
    .setDescription(peakList)
    .setColor(0x9932CC)
    .setFooter({ text: 'Based on LFG activity' });
  await message.reply({ embeds: [embed] });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SETUP ACTIVITIES - Creates activity-guide channel
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function handleSetupActivities(message) {
  if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
    return message.reply('Admin only.');
  }

  const statusMsg = await message.reply('ğŸ”§ Creating activity guide...');

  try {
    const guild = message.guild;
    const categoryId = '1454372554037923937';

    // Create #activity-guide (read-only)
    const guideChannel = await guild.channels.create({
      name: 'activity-guide',
      type: 0,
      parent: categoryId,
      topic: 'ğŸ“– Learn how to use all activity features!',
      permissionOverwrites: [
        {
          id: guild.id,
          deny: [PermissionFlagsBits.SendMessages],
          allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.ReadMessageHistory]
        }
      ]
    });

    // Move to top of category
    await guideChannel.setPosition(0).catch(() => {});

    // Casino embed
    const casinoEmbed = new EmbedBuilder()
      .setTitle('ğŸ° CASINO')
      .setDescription(`
**Use these commands in #casino**

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’µ **GET CHIPS:**
\`?daily\` - Free daily chips (streak bonus!)
\`?work\` - Earn chips (30min cooldown)
\`?crime\` - High risk, high reward (1hr cooldown)

ğŸ² **GAMBLE:**
\`?slots 100\` - Spin the slots
\`?coinflip 50 heads\` - 50/50 bet
\`?blackjack 100\` - Play 21
\`?roulette 100 red\` - Spin the wheel

ğŸ“Š **OTHER:**
\`?balance\` - Check your chips
\`?pay @user 100\` - Send chips
\`?richest\` - Leaderboard

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      `)
      .setColor(0xFFD700);

    // AI Lab embed
    const aiEmbed = new EmbedBuilder()
      .setTitle('ğŸ¨ AI LAB')
      .setDescription(`
**Use these commands in #ai-lab**

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ–¼ï¸ **IMAGES:**
\`?generate [prompt]\` - Create any image
\`?wanted @user\` - GTA wanted poster
\`?bounty @user\` - RDO bounty poster
\`?victory [text]\` - Victory screen

ğŸ¬ **VIDEO:**
\`?video [prompt]\` - Generate short video
*(Takes 1-2 minutes)*

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

**Examples:**
\`?generate epic sunset over Los Santos\`
\`?wanted @friend\`
\`?video car chase through city at night\`
      `)
      .setColor(0x9932CC);

    // Crew Finder embed
    const crewEmbed = new EmbedBuilder()
      .setTitle('ğŸ¤ CREW FINDER')
      .setDescription(`
**Use these commands in #crew-finder**

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â­ **REPUTATION:**
\`?rep @user\` - Check someone's reputation
\`?rate @user 1-5\` - Rate after playing together
\`?partners\` - See your frequent crew
\`?connection @user\` - Your history with someone

ğŸ“Š **PLANNING:**
\`?plan 60 2\` - Best activities for 60min with 2 players
\`?mytime\` - Your optimal LFG time
\`?peaktimes\` - When server is most active

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

**Check \`?rep\` before joining randoms!**
**Rate good teammates to boost their rep!**
      `)
      .setColor(0x00BFFF);

    // Send all embeds
    await guideChannel.send({ embeds: [casinoEmbed] });
    await guideChannel.send({ embeds: [aiEmbed] });
    await guideChannel.send({ embeds: [crewEmbed] });

    await statusMsg.edit(`âœ… Created #activity-guide (read-only)

Users can see the instructions but can't type there.`);

  } catch (error) {
    console.error('Setup activities error:', error);
    await statusMsg.edit(`âŒ Error: ${error.message}`);
  }
}

client.login(process.env.DISCORD_TOKEN);
